{"version":3,"file":"maptalks.markercluster.es.js","sources":["../index.js"],"sourcesContent":["import * as maptalks from 'maptalks';\nimport { reshader } from '@maptalks/gl';\nimport { getVectorPacker, PointLayerRenderer } from '@maptalks/vt';\nimport vert from './glsl/sprite.vert';\nimport frag from './glsl/sprite.frag';\nimport wgslVert from './wgsl/sprite_vert.wgsl';\nimport wgslFrag from './wgsl/sprite_frag.wgsl';\n\nconst FONT_CANVAS = document.createElement('canvas');\nconst fontCtx = FONT_CANVAS.getContext('2d');\nconst ZERO_POINT = new maptalks.Point(0, 0);\n\nconst MarkerLayerClazz = maptalks.DrawToolLayer.markerLayerClazz;\nlet renderer = 'canvas';\nconst RendererClazz = MarkerLayerClazz.getRendererClass('canvas');\nif (!RendererClazz) {\n    renderer = 'gl';\n}\n\nconst options = {\n    'renderer': renderer,\n    'maxClusterRadius' : 160,\n    'textSumProperty' : null,\n    'symbol' : null,\n    'drawClusterText' : true,\n    'textSymbol' : null,\n    'animation' : true,\n    'animationDuration' : 450,\n    'maxClusterZoom' : null,\n    'noClusterWithOneMarker':true,\n    'forceRenderOnZooming' : true\n};\n\nexport class ClusterLayer extends MarkerLayerClazz {\n    /**\n     * Reproduce a ClusterLayer from layer's profile JSON.\n     * @param  {Object} json - layer's profile JSON\n     * @return {maptalks.ClusterLayer}\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(json) {\n        if (!json || json['type'] !== 'ClusterLayer') { return null; }\n        const layer = new ClusterLayer(json['id'], json['options']);\n        const geoJSONs = json['geometries'];\n        const geometries = [];\n        for (let i = 0; i < geoJSONs.length; i++) {\n            const geo = maptalks.Geometry.fromJSON(geoJSONs[i]);\n            if (geo) {\n                geometries.push(geo);\n            }\n        }\n        layer.addGeometry(geometries);\n        return layer;\n    }\n\n    addMarker(markers) {\n        return this.addGeometry(markers);\n    }\n\n    addGeometry(markers) {\n        for (let i = 0, len = markers.length; i < len; i++) {\n            if (!(markers[i] instanceof maptalks.Marker)) {\n                throw new Error('Only a point(Marker) can be added into a ClusterLayer');\n            }\n        }\n        return super.addGeometry.apply(this, arguments);\n    }\n\n    onConfig(conf) {\n        super.onConfig(conf);\n        if (conf['maxClusterRadius'] ||\n            conf['symbol'] ||\n            conf['drawClusterText'] ||\n            conf['textSymbol'] ||\n            conf['maxClusterZoom']) {\n            const renderer = this._getRenderer();\n            if (renderer) {\n                renderer.render();\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Identify the clusters on the given coordinate\n     * @param  {maptalks.Coordinate} coordinate   - coordinate to identify\n     * @return {Object|Geometry[]}  result: cluster { center : [cluster's center], children : [geometries in the cluster] } or markers\n     */\n    identify(coordinate, options) {\n        const map = this.getMap(),\n            maxZoom = this.options['maxClusterZoom'];\n        if (maxZoom && map && map.getZoom() > maxZoom) {\n            return super.identify(coordinate, options);\n        }\n        if (this._getRenderer()) {\n            return this._getRenderer().identify(coordinate, options);\n        }\n        return null;\n    }\n\n    /**\n     * Export the ClusterLayer's JSON.\n     * @return {Object} layer's JSON\n     */\n    toJSON() {\n        const json = super.toJSON.call(this);\n        json['type'] = 'ClusterLayer';\n        return json;\n    }\n    /**\n     * Get the ClusterLayer's current clusters\n     * @return {Object} layer's clusters\n     **/\n    getClusters() {\n        const renderer = this._getRenderer();\n        if (renderer) {\n            return renderer._currentClusters || [];\n        }\n        return [];\n    }\n}\n\n// merge to define ClusterLayer's default options.\nClusterLayer.mergeOptions(options);\n\n// register ClusterLayer's JSON type for JSON deserialization.\nClusterLayer.registerJSONType('ClusterLayer');\n\nconst defaultTextSymbol = {\n    'textFaceName'      : '\"microsoft yahei\"',\n    'textSize'          : 16,\n    'textDx'            : 0,\n    'textDy'            : 0\n};\n\nconst defaultSymbol = {\n    'markerType' : 'ellipse',\n    'markerFill' : { property:'count', type:'interval', stops: [[0, 'rgb(135, 196, 240)'], [9, '#1bbc9b'], [99, 'rgb(216, 115, 149)']] },\n    'markerFillOpacity' : 0.7,\n    'markerLineOpacity' : 1,\n    'markerLineWidth' : 3,\n    'markerLineColor' : '#fff',\n    'markerWidth' : { property:'count', type:'interval', stops: [[0, 40], [9, 60], [99, 80]] },\n    'markerHeight' : { property:'count', type:'interval', stops: [[0, 40], [9, 60], [99, 80]] }\n};\n\nconst ClusterLayerRenderable = function(Base) {\n    const renderable = class extends Base {\n        init() {\n            this._refreshStyle();\n            this._clusterNeedRedraw = true;\n        }\n\n        checkResources() {\n            if (!super.checkResources) {\n                return [];\n            }\n            const symbol = this.layer.options['symbol'] || defaultSymbol;\n            const resources = super.checkResources.apply(this, arguments);\n            if (symbol !== this._symbolResourceChecked) {\n                const res = maptalks.Util.getExternalResources(symbol, true);\n                if (res) {\n                    resources.push.apply(resources, res);\n                }\n                this._symbolResourceChecked = symbol;\n            }\n            return resources;\n        }\n\n        draw(timestamp, parentContext) {\n            if (!this.canvas) {\n                this.prepareCanvas();\n            }\n            const map = this.getMap();\n            const zoom = map.getZoom();\n            const maxClusterZoom = this.layer.options['maxClusterZoom'];\n            if (maxClusterZoom &&  zoom > maxClusterZoom) {\n                delete this._currentClusters;\n                this.checkMarksToDraw();\n                super.draw.apply(this, arguments);\n                return;\n            }\n            if (this._clusterNeedRedraw) {\n                this._clearDataCache();\n                this._computeGrid();\n                this._clusterNeedRedraw = false;\n            }\n            let clusters;\n            if (this._triggerAnimate) {\n                this._startAnimation(zoom);\n            }\n            if (this._animateDelta) {\n                clusters = this._animateClusters;\n            } else {\n                const zoomClusters = this._clusterCache[zoom] ? this._clusterCache[zoom]['clusters'] : null;\n                clusters = this.getClustersToDraw(zoomClusters);\n                clusters.zoom = zoom;\n            }\n            this._drawLayer(clusters, timestamp, parentContext);\n        }\n\n        _startAnimation(zoom) {\n            const zoomClusters = this._clusterCache[zoom] ? this._clusterCache[zoom]['clusters'] : null;\n            const clusters = this.getClustersToDraw(zoomClusters);\n            clusters.zoom = zoom;\n\n            this._animateClusters = clusters;\n            this._parentClusters = this._currentClusters || clusters;\n            const layer = this.layer;\n            if (layer.options['animation'] && this._triggerAnimate) {\n                let dr = [0, 1];\n                if (this._inout === 'in') {\n                    dr = [1, 0];\n                }\n                this._animateDelta = dr[0];\n                this._animating = true;\n                this._player = maptalks.animation.Animation.animate(\n                    { 'd' : dr },\n                    { 'speed' : layer.options['animationDuration'], 'easing' : 'inAndOut' },\n                    frame => {\n                        this._animateDelta = frame.styles.d;\n                        if (frame.state.playState === 'finished') {\n                            delete this._animateDelta;\n                            delete this._inout;\n                            delete this._animateClusters;\n                            delete this._parentClusters\n                            delete this._animating;\n                        }\n                        this.setToRedraw();\n                    }\n                )\n                .play();\n                this.setToRedraw();\n            }\n            this._triggerAnimate = false;\n        }\n\n        checkMarksToDraw() {\n            const dirty = this._markersToDraw !== this.layer._geoList;\n            this._markersToDraw = this.layer._geoList;\n            this._isMarkersDirty = dirty;\n        }\n\n        getClustersToDraw(zoomClusters) {\n            const oldMarkersToDraw = this._markersToDraw || [];\n            this._markersToDraw = [];\n            const map = this.getMap();\n            const font = maptalks.StringUtil.getFont(this._textSymbol),\n                digitLen = maptalks.StringUtil.stringLength('9', font).toPoint();\n            const extent = map.getContainerExtent(),\n                clusters = [];\n            let pt, pExt, sprite, width, height, markerIndex = 0, isMarkerDirty = false;\n            for (const p in zoomClusters) {\n                this._currentGrid = zoomClusters[p];\n                if (zoomClusters[p]['count'] === 1 && this.layer.options['noClusterWithOneMarker']) {\n                    const marker = zoomClusters[p]['children'][0];\n                    marker._cluster = zoomClusters[p];\n                    if (!isMarkerDirty && oldMarkersToDraw[markerIndex++] !== marker) {\n                        isMarkerDirty = true;\n                    }\n                    this._markersToDraw.push(marker);\n                    continue;\n                }\n                sprite = this._getSprite().sprite;\n                width = sprite.canvas.width;\n                height = sprite.canvas.height;\n                pt = map._prjToContainerPoint(zoomClusters[p]['center']);\n                pExt = new maptalks.PointExtent(pt.sub(width, height), pt.add(width, height));\n                if (!extent.intersects(pExt)) {\n                    continue;\n                }\n                if (!zoomClusters[p]['textSize']) {\n                    const text = this._getClusterText(zoomClusters[p]);\n                    zoomClusters[p]['textSize'] = new maptalks.Point(digitLen.x * text.length, digitLen.y)._multi(1 / 2);\n                }\n                clusters.push(zoomClusters[p]);\n            }\n            if (oldMarkersToDraw.length !== this._markersToDraw.length) {\n                isMarkerDirty = true;\n            }\n            this._isMarkersDirty = this._isMarkersDirty || isMarkerDirty;\n            return clusters;\n        }\n\n        drawOnInteracting(...args) {\n            if (this._currentClusters) {\n                this.drawClusters(this._currentClusters, 1);\n            }\n            super.drawOnInteracting(...args);\n        }\n\n        getCurrentNeedRenderGeos() {\n            if (this._markersToDraw) {\n                return this._markersToDraw;\n            }\n            return [];\n        }\n\n        _getCurrentNeedRenderGeos() {\n            return this.getCurrentNeedRenderGeos();\n        }\n\n        forEachGeo(fn, context) {\n            if (this._markersToDraw) {\n                this._markersToDraw.forEach((g) => {\n                    if (context) {\n                        fn.call(context, g);\n                    } else {\n                        fn(g);\n                    }\n                });\n            }\n        }\n\n        onGeometryShow() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryShow.apply(this, arguments);\n        }\n\n        onGeometryHide() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryHide.apply(this, arguments);\n        }\n\n        onGeometryAdd() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryAdd.apply(this, arguments);\n        }\n\n        onGeometryRemove() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryRemove.apply(this, arguments);\n        }\n\n        onGeometryPositionChange() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryPositionChange.apply(this, arguments);\n        }\n\n        onRemove() {\n            this._clearDataCache();\n        }\n\n        identify(coordinate, options) {\n            const map = this.getMap(),\n                maxZoom = this.layer.options['maxClusterZoom'];\n            if (maxZoom && map.getZoom() > maxZoom) {\n                return super.identify(coordinate, options);\n            }\n            if (this._currentClusters) {\n                const point = map.coordinateToContainerPoint(coordinate);\n                const old = this._currentGrid;\n                for (let i = 0; i < this._currentClusters.length; i++) {\n                    const c = this._currentClusters[i];\n                    const pt = map._prjToContainerPoint(c['center']);\n                    this._currentGrid = c;\n                    const markerWidth = this._getSprite().sprite.canvas.width;\n\n                    if (point.distanceTo(pt) <= markerWidth) {\n                        return {\n                            'center'   : map.getProjection().unproject(c.center.copy()),\n                            'children' : c.children.slice(0)\n                        };\n                    }\n                }\n                this._currentGrid = old;\n            }\n\n            // if no clusters is hit, identify markers\n            if (this._markersToDraw && this._markersToDraw[0]) {\n                const point = map.coordinateToContainerPoint(coordinate);\n                return this.layer._hitGeos(this._markersToDraw, point, options);\n            }\n            return null;\n        }\n\n        onSymbolChanged() {\n            this._refreshStyle();\n            this._computeGrid();\n            this._stopAnim();\n            this.setToRedraw();\n        }\n\n        _refreshStyle() {\n            const symbol = this.layer.options['symbol'] || defaultSymbol;\n            const textSymbol = this.layer.options['textSymbol'] || defaultTextSymbol;\n            const argFn =  () => [this.getMap().getZoom(), this._currentGrid];\n            this._symbol = maptalks.MapboxUtil.loadFunctionTypes(symbol, argFn);\n            this._textSymbol = maptalks.MapboxUtil.loadFunctionTypes(textSymbol, argFn);\n        }\n\n        _drawLayer(clusters, timestamp, parentContext) {\n            this._currentClusters = clusters;\n            if (this._animateDelta >= 0) {\n                if (this._inout === 'in') {\n                    this.drawClustersFrame(clusters, this._parentClusters, this._animateDelta);\n                } else {\n                    this.drawClustersFrame(this._parentClusters, clusters, this._animateDelta);\n                }\n            } else {\n                this.drawClusters(clusters, 1);\n            }\n            this.drawMarkers(timestamp, parentContext);\n            this.completeRender();\n        }\n\n        drawMarkers() {\n            super.drawGeos();\n        }\n\n        drawClustersFrame(parentClusters, toClusters, ratio) {\n            this.prepareCanvas();\n            const map = this.getMap(),\n                drawn = {};\n            if (parentClusters) {\n                parentClusters.forEach(c => {\n                    const p = map._prjToContainerPoint(c['center']);\n                    if (!drawn[c.key]) {\n                        drawn[c.key] = 1;\n                        this.drawCluster(p, c, 1 - ratio);\n                    }\n                });\n            }\n            if (ratio === 0 || !toClusters) {\n                return;\n            }\n            const z = parentClusters.zoom,\n                r = map._getResolution(z) * this.layer.options['maxClusterRadius'],\n                min = this._markerExtent.getMin();\n            toClusters.forEach(c => {\n                let pt = map._prjToContainerPoint(c['center']);\n                const center = c.center;\n                const pgx = Math.floor((center.x - min.x) / r),\n                    pgy = Math.floor((center.y - min.y) / r);\n                const pkey = pgx + '_' + pgy;\n                const parent = this._clusterCache[z] ? this._clusterCache[z]['clusterMap'][pkey] : null;\n                if (parent) {\n                    const pp = map._prjToContainerPoint(parent['center']);\n                    pt = pp.add(pt.sub(pp)._multi(ratio));\n                }\n                this.drawCluster(pt, c, ratio > 0.5 ? 1 : ratio);\n            });\n        }\n\n        drawClusters(clusters, ratio) {\n            if (!clusters) {\n                return;\n            }\n            this.prepareCanvas();\n            const map = this.getMap();\n            clusters.forEach(c => {\n                const pt = map._prjToContainerPoint(c['center']);\n                this.drawCluster(pt, c, ratio > 0.5 ? 1 : ratio);\n            });\n\n        }\n\n        drawCluster(pt, cluster, op) {\n            this._currentGrid = cluster;\n            const ctx = this.context;\n            const sprite = this._getSprite().sprite;\n            const opacity = ctx.globalAlpha;\n            if (opacity * op === 0) {\n                return;\n            }\n            ctx.globalAlpha = opacity * op;\n            if (sprite) {\n                const pos = pt.add(sprite.offset)._sub(sprite.canvas.width / 2, sprite.canvas.height / 2);\n                maptalks.Canvas.image(ctx, sprite.canvas, pos.x, pos.y);\n            }\n\n            if (this.layer.options['drawClusterText'] && cluster['textSize']) {\n                maptalks.Canvas.prepareCanvasFont(ctx, this._textSymbol);\n                ctx.textBaseline = 'middle';\n                const dx = this._textSymbol['textDx'] || 0;\n                const dy = this._textSymbol['textDy'] || 0;\n                const text = this._getClusterText(cluster);\n                maptalks.Canvas.fillText(ctx, text, pt.sub(cluster['textSize'].x, 0)._add(dx, dy));\n            }\n            ctx.globalAlpha = opacity;\n        }\n\n        _getClusterText(cluster) {\n            const text = this.layer.options['textSumProperty'] ? cluster['textSumProperty'] : cluster['count'];\n            return text + '';\n        }\n\n        _getSprite() {\n            if (!this._spriteCache) {\n                this._spriteCache = {};\n            }\n            const key = getSymbolStamp(this._symbol);\n            if (!this._spriteCache[key]) {\n                this._spriteCache[key] = new maptalks.Marker([0, 0], { 'symbol' : this._symbol })._getSprite(this.resources, this.getMap().CanvasClass);\n            }\n            return {\n                sprite: this._spriteCache[key],\n                key\n            };\n        }\n\n        _initGridSystem() {\n            const points = [];\n            let extent, c;\n            this.layer.forEach(g => {\n                if (!g.isVisible()) {\n                    return;\n                }\n                c = g._getPrjCoordinates();\n                if (!extent) {\n                    extent = g._getPrjExtent();\n                } else {\n                    extent = extent._combine(g._getPrjExtent());\n                }\n                points.push({\n                    x : c.x,\n                    y : c.y,\n                    id : g._getInternalId(),\n                    geometry : g\n                });\n            });\n            this._markerExtent = extent;\n            this._markerPoints = points;\n        }\n\n        _computeGrid() {\n            const map = this.getMap(),\n                zoom = map.getZoom();\n            if (!this._markerExtent) {\n                this._initGridSystem();\n            }\n            if (!this._clusterCache) {\n                this._clusterCache = {};\n            }\n            const pre = map._getResolution(map.getMinZoom()) > map._getResolution(map.getMaxZoom()) ? zoom - 1 : zoom + 1;\n            if (this._clusterCache[pre] && this._clusterCache[pre].length === this.layer.getCount()) {\n                this._clusterCache[zoom] = this._clusterCache[pre];\n            }\n            if (!this._clusterCache[zoom]) {\n                this._clusterCache[zoom] = this._computeZoomGrid(zoom);\n            }\n        }\n\n        _computeZoomGrid(zoom) {\n            if (!this._markerExtent) {\n                return null;\n            }\n            const map = this.getMap(),\n                r = map._getResolution(zoom) * this.layer.options['maxClusterRadius'],\n                preT = map._getResolution(zoom - 1) ? map._getResolution(zoom - 1) * this.layer.options['maxClusterRadius'] : null;\n            let preCache = this._clusterCache[zoom - 1];\n            if (!preCache && zoom - 1 >= map.getMinZoom()) {\n                this._clusterCache[zoom - 1] = preCache = this._computeZoomGrid(zoom - 1);\n            }\n            // 1. format extent of markers to grids with raidus of r\n            // 2. find point's grid in the grids\n            // 3. sum up the point into the grid's collection\n            const points = this._markerPoints;\n            const sumProperty = this.layer.options['textSumProperty'];\n            const grids = {},\n                min = this._markerExtent.getMin();\n            let gx, gy, key,\n                pgx, pgy, pkey;\n            for (let i = 0, len = points.length; i < len; i++) {\n                const geo = points[i].geometry;\n                let sumProp = 0;\n\n                if (sumProperty && geo.getProperties() && geo.getProperties()[sumProperty]) {\n                    sumProp = geo.getProperties()[sumProperty];\n                }\n\n                gx = Math.floor((points[i].x - min.x) / r);\n                gy = Math.floor((points[i].y - min.y) / r);\n                key = gx + '_' + gy;\n                if (!grids[key]) {\n                    grids[key] = {\n                        'sum' : new maptalks.Coordinate(points[i].x, points[i].y),\n                        'center' : new maptalks.Coordinate(points[i].x, points[i].y),\n                        'count' : 1,\n                        'textSumProperty' : sumProp,\n                        'children' :[geo],\n                        'key' : key + ''\n                    };\n                    if (preT && preCache) {\n                        pgx = Math.floor((points[i].x - min.x) / preT);\n                        pgy = Math.floor((points[i].y - min.y) / preT);\n                        pkey = pgx + '_' + pgy;\n                        grids[key]['parent'] = preCache['clusterMap'][pkey];\n                    }\n                } else {\n\n                    grids[key]['sum']._add(new maptalks.Coordinate(points[i].x, points[i].y));\n                    grids[key]['count']++;\n                    grids[key]['center'] = grids[key]['sum'].multi(1 / grids[key]['count']);\n                    grids[key]['children'].push(geo);\n                    grids[key]['textSumProperty'] += sumProp;\n                }\n            }\n            return this._mergeClusters(grids, r / 2);\n        }\n\n        _mergeClusters(grids, r) {\n            const clusterMap = {};\n            for (const p in grids) {\n                clusterMap[p] = grids[p];\n            }\n\n            // merge adjacent clusters\n            const merging = {};\n\n            const visited = {};\n            // find clusters need to merge\n            let c1, c2;\n            for (const p in grids) {\n                c1 = grids[p];\n                if (visited[c1.key]) {\n                    continue;\n                }\n                const gxgy = c1.key.split('_');\n                const gx = +(gxgy[0]),\n                    gy = +(gxgy[1]);\n                //traverse adjacent grids\n                for (let ii = -1; ii <= 1; ii++) {\n                    for (let iii = -1; iii <= 1; iii++) {\n                        if (ii === 0 && iii === 0) {\n                            continue;\n                        }\n                        const key2 = (gx + ii) + '_' + (gy + iii);\n                        c2 = grids[key2];\n                        if (c2 && this._distanceTo(c1['center'], c2['center']) <= r) {\n                            if (!merging[c1.key]) {\n                                merging[c1.key] = [];\n                            }\n                            merging[c1.key].push(c2);\n                            visited[c2.key] = 1;\n                        }\n                    }\n                }\n            }\n\n            //merge clusters\n            for (const m in merging) {\n                const grid = grids[m];\n                if (!grid) {\n                    continue;\n                }\n                const toMerge = merging[m];\n                for (let i = 0; i < toMerge.length; i++) {\n                    if (grids[toMerge[i].key]) {\n                        grid['sum']._add(toMerge[i].sum);\n                        grid['count'] += toMerge[i].count;\n                        grid['textSumProperty'] += toMerge[i].textSumProperty;\n                        grid['children'] = grid['children'].concat(toMerge[i].children);\n                        clusterMap[toMerge[i].key] = grid;\n                        delete grids[toMerge[i].key];\n                    }\n                }\n                grid['center'] = grid['sum'].multi(1 / grid['count']);\n            }\n\n            return {\n                'clusters' : grids,\n                'clusterMap' : clusterMap\n            };\n        }\n\n        _distanceTo(c1, c2) {\n            const x = c1.x - c2.x,\n                y = c1.y - c2.y;\n            return Math.sqrt(x * x + y * y);\n        }\n\n        _stopAnim() {\n            if (this._player && this._player.playState !== 'finished') {\n                this._player.finish();\n            }\n        }\n\n        onZoomStart(param) {\n            this._stopAnim();\n            super.onZoomStart(param);\n        }\n\n        onZoomEnd(param) {\n            if (this.layer.isEmpty() || !this.layer.isVisible()) {\n                super.onZoomEnd.apply(this, arguments);\n                return;\n            }\n            this._inout = param['from'] > param['to'] ? 'in' : 'out';\n            this._triggerAnimate = true;\n            this._computeGrid();\n            super.onZoomEnd.apply(this, arguments);\n        }\n\n        _clearDataCache() {\n            this._stopAnim();\n            delete this._markerExtent;\n            delete this._markerPoints;\n            delete this._clusterCache;\n            delete this._zoomInClusters;\n        }\n    };\n    return renderable;\n}\n\nclass ClusterLayerRenderer extends ClusterLayerRenderable(maptalks.renderer.VectorLayerCanvasRenderer) {\n\n    constructor(...args) {\n        super(...args);\n        this.init();\n    }\n}\n\nClusterLayer.registerRenderer('canvas', ClusterLayerRenderer);\n\nif (typeof PointLayerRenderer !== 'undefined') {\n    class ClusterGLRenderer extends ClusterLayerRenderable(PointLayerRenderer) {\n        constructor(...args) {\n            super(...args);\n            this.init();\n        }\n\n        drawOnInteracting(event, timestamp, parentContext) {\n            if (this._currentClusters) {\n                this.drawClusters(this._currentClusters, 1);\n            }\n            this.drawMarkers(timestamp, parentContext);\n            // PointLayerRenderer.prototype.draw.call(this, timestamp, parentContext);\n        }\n\n        drawClusters(...args) {\n            this._clearToDraw();\n            super.drawClusters(...args);\n            this.flush();\n        }\n\n        drawClustersFrame(...args) {\n            this._clearToDraw();\n            super.drawClustersFrame(...args);\n            this.flush();\n        }\n\n        _clearToDraw() {\n            this.pointCount = 0;\n            this.bufferIndex = 0;\n            this.opacityIndex = 0;\n            this.textIndex = 0;\n        }\n\n        drawCluster(pt, cluster, opacity) {\n            this._currentGrid = cluster;\n            const { sprite, key } = this._getSprite();\n            const canvas = sprite.canvas;\n            if (!sprite.data) {\n                sprite.data = canvas.getContext('2d', { willReadFrequently: true }).getImageData(0, 0, canvas.width, canvas.height);\n            }\n            if (!this.clusterSprites[key]) {\n                this.clusterSprites[key] = sprite;\n                this.textureDirty = true;\n            }\n            const pos = pt.add(sprite.offset)._sub(canvas.width / 2, canvas.height / 2);\n            let x = pos.x;\n            let y = pos.y;\n            const map = this.getMap();\n            const pixelRatio = map.getDevicePixelRatio();\n            const height = map.height;\n            x = x * pixelRatio;\n            y = (height - y) * pixelRatio;\n            const spriteW = sprite.data.width * pixelRatio;\n            const spriteH = sprite.data.height * pixelRatio;\n\n            this.addPoint(x, y, spriteW, spriteH, opacity, key);\n\n            if (this.layer.options['drawClusterText']) {\n                maptalks.Canvas.prepareCanvasFont(fontCtx, this._textSymbol);\n                const fontKey = fontCtx.font + '-' + fontCtx.fillStyle;\n                const text = this._getClusterText(cluster);\n                const { sprite, key } = this._getTextSprite(text, fontKey);\n                if (!this.clusterTextSprites[key]) {\n                    this.clusterTextSprites[key] = sprite;\n                    this.textTextureDirty = true;\n                }\n                this.addTextPoint(x + spriteW / 2, y - spriteH / 2, sprite.data.width * pixelRatio, sprite.data.height * pixelRatio, key);\n            }\n            this.pointCount++;\n\n        }\n\n        _getTextSprite(text, fontKey) {\n            if (!this._textSpriteCache) {\n                this._textSpriteCache = {};\n            }\n            const key = fontKey + '-' + text;\n            if (!this._textSpriteCache[key]) {\n                const dpr = this.getMap().getDevicePixelRatio();\n                const metrics = fontCtx.measureText(text);\n                const textWidth = metrics.width;\n                const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n                const canvas = document.createElement('canvas');\n                canvas.width = textWidth * dpr;\n                canvas.height = textHeight * dpr;\n                const ctx = canvas.getContext('2d', { willReadFrequently: true });\n                ctx.scale(dpr, dpr);\n                maptalks.Canvas.prepareCanvasFont(ctx, this._textSymbol);\n                ctx.textBaseline = 'top';\n                ctx.fillText(text, 0, 0);\n                const debugCanvas = document.getElementById('debug-text-sprite');\n                if (debugCanvas) {\n                    debugCanvas.width = canvas.width;\n                    debugCanvas.height = canvas.height;\n                    const ctx = debugCanvas.getContext('2d');\n                    ctx.drawImage(canvas, 0, 0);\n                }\n\n                this._textSpriteCache[key] = {\n                    canvas,\n                    offset: ZERO_POINT,\n                    data: ctx.getImageData(0, 0, canvas.width, canvas.height)\n                };\n            }\n            return {\n                sprite: this._textSpriteCache[key],\n                key\n            };\n        }\n\n        checkMarksToDraw() {\n            super.checkMarksToDraw();\n            this._checkToRebuildGeometry();\n        }\n\n        drawMarkers(timestamp, parentContext) {\n            this._checkToRebuildGeometry();\n            if (!this._animating) {\n                PointLayerRenderer.prototype.draw.call(this, timestamp, parentContext);\n            }\n\n        }\n\n        _checkToRebuildGeometry() {\n            // only rebuild when not animating or interacting\n            if (this._isMarkersDirty && !this.isInteractingOrAnimating()) {\n                this.rebuildGeometries();\n                this._isMarkersDirty = false;\n            }\n        }\n\n        isInteractingOrAnimating() {\n            return this.getMap().isZooming() || this._animating;\n        }\n\n        flush(parentContext) {\n            if (this.pointCount === 0) {\n                return;\n            }\n            this._updateMesh();\n            const fbo = parentContext && parentContext.renderTarget && context.renderTarget.fbo;\n            this._clusterGeometry.setDrawCount(this.pointCount * 6);\n            const { width, height } = this.canvas;\n            const layerOpacity = this._getLayerOpacity();\n            const uniforms = {\n                resolution: [width, height],\n                layerOpacity,\n                dxDy: [0, 0]\n            };\n            this._renderer.render(this._spriteShader, uniforms, this._scene, fbo);\n\n            if (this.layer.options['drawClusterText']) {\n                this._textGeometry.setDrawCount(this.pointCount * 6);\n                const dx = this._textSymbol['textDx'] || 0;\n                const dy = this._textSymbol['textDy'] || 0;\n                uniforms.dxDy = [dx, dy];\n                this._renderer.render(this._spriteShader, uniforms, this._textScene, fbo);\n            }\n        }\n\n        _updateMesh() {\n\n            const isAtlasDirty = this.textureDirty;\n            const atlas = this._genAtlas();\n            this._updateTexCoord(atlas, isAtlasDirty);\n            // text\n            if (this.layer.options['drawClusterText']) {\n                const isAtlasDirty = this.textTextureDirty;\n                const textAtlas = this._genTextAtlas();\n                this._updateTextTexCoord(textAtlas, isAtlasDirty);\n            }\n\n            this._updateGeometryData();\n        }\n\n        addPoint(x, y, width, height, opacity, key) {\n            this._check();\n            const w = width;\n            const h = height;\n\n            this.addVertex(x, y - h, opacity);\n            this.addVertex(x + w, y - h, opacity);\n            this.addVertex(x, y, opacity);\n            this.addVertex(x, y, opacity);\n            this.addVertex(x + w, y - h, opacity);\n            this.addVertex(x + w, y, opacity);\n            if (this.sprites[this.pointCount] !== key) {\n                this.sprites[this.pointCount] = key;\n                this.sprites.dirty = true;\n            }\n        }\n\n        addVertex(x, y, opacity) {\n            const positionBufferData = this.positionBufferData;\n            if (positionBufferData[this.bufferIndex] !== x) {\n                positionBufferData[this.bufferIndex] = x;\n                positionBufferData.dirty = true;\n            }\n            this.bufferIndex++;\n            if (positionBufferData[this.bufferIndex] !== y) {\n                positionBufferData[this.bufferIndex] = y;\n                positionBufferData.dirty = true;\n            }\n            this.bufferIndex++;\n\n            const opacityBufferData = this.opacityBufferData;\n            // opacity *= 255;\n            // U8[0] = opacity;\n            if (opacityBufferData[this.opacityIndex] !== opacity) {\n                opacityBufferData[this.opacityIndex] = opacity;\n                opacityBufferData.dirty = true;\n            }\n            this.opacityIndex++;\n        }\n\n        addTextPoint(x, y, width, height, key) {\n            this._check();\n            const dpr = this.getMap().getDevicePixelRatio();\n            width /= dpr;\n            height /= dpr;\n            const w = width / 2;\n            const h = height / 2;\n\n            this.addTextVertex(x - w, y - h);\n            this.addTextVertex(x + w, y - h);\n            this.addTextVertex(x - w, y + h);\n            this.addTextVertex(x - w, y + h);\n            this.addTextVertex(x + w, y - h);\n            this.addTextVertex(x + w, y + h);\n\n            if (this.textSprites[this.pointCount] !== key) {\n                this.textSprites[this.pointCount] = key;\n                this.textSprites.dirty = true;\n            }\n        }\n\n        addTextVertex(x, y) {\n            const textPositionData = this.textPositionData;\n            if (textPositionData[this.textIndex] !== x) {\n                textPositionData[this.textIndex] = x;\n                textPositionData.dirty = true;\n            }\n            this.textIndex++;\n            if (textPositionData[this.textIndex] !== y) {\n                textPositionData[this.textIndex] = y;\n                textPositionData.dirty = true;\n            }\n            this.textIndex++;\n        }\n\n        _check() {\n            if (this.pointCount >= this.maxPointCount - 1) {\n                this.maxPointCount += 1024;\n                const { positionBufferData, texCoordBufferData, opacityBufferData, textPositionData, textTexCoordData } = this._initBuffers();\n                for (let i = 0; i < this.bufferIndex; i++) {\n                    positionBufferData[i] = this.positionBufferData[i];\n                    texCoordBufferData[i] = this.texCoordBufferData[i];\n                    textPositionData[i] = this.textPositionData[i];\n                    textTexCoordData[i] = this.textTexCoordData[i];\n                }\n                for (let i = 0; i < this.opacityIndex; i++) {\n                    opacityBufferData[i] = this.opacityBufferData[i];\n                }\n                this.positionBufferData = positionBufferData;\n                this.texCoordBufferData = texCoordBufferData;\n                this.opacityBufferData = opacityBufferData;\n                this.textPositionData = textPositionData;\n                this.textTexCoordData = textTexCoordData;\n            }\n        }\n\n        _updateGeometryData() {\n            // icon\n            if (this.positionBufferData.dirty) {\n                this._clusterGeometry.updateData('aPosition', this.positionBufferData);\n                // console.log(this.positionBufferData);\n                this.positionBufferData.dirty = false;\n            }\n            if (this.opacityBufferData.dirty) {\n                this._clusterGeometry.updateData('aOpacity', this.opacityBufferData);\n                this._textGeometry.updateData('aOpacity', this.opacityBufferData);\n                this.opacityBufferData.dirty = false;\n            }\n            if (this.texCoordBufferData.dirty) {\n                this._clusterGeometry.updateData('aTexCoord', this.texCoordBufferData);\n                this.texCoordBufferData.dirty = false;\n            }\n\n            // text\n            if (this.textPositionData.dirty) {\n                this._textGeometry.updateData('aPosition', this.textPositionData);\n                this.textPositionData.dirty = false;\n            }\n            if (this.textTexCoordData.dirty) {\n                this._textGeometry.updateData('aTexCoord', this.textTexCoordData);\n                this.textTexCoordData.dirty = false;\n            }\n        }\n\n        _updateTexCoord(atlas, isAtlasDirty) {\n            if (!this.sprites.dirty && !isAtlasDirty) {\n                return;\n            }\n            const { positions, image } = atlas;\n            const { width, height } = image;\n            this.texCoordIndex = 0;\n            for (let i = 0; i < this.pointCount; i++) {\n                const bin = positions[this.sprites[i]];\n                const { tl, br } = bin;\n                this._fillTexCoord(tl, br, width, height);\n            }\n            this.sprites.dirty = false;\n        }\n\n        _updateTextTexCoord(atlas, isAtlasDirty) {\n            if (!this.textSprites.dirty && !isAtlasDirty) {\n                return;\n            }\n            const { positions, image } = atlas;\n            const { width, height } = image;\n            this.textTexCoordIndex = 0;\n            for (let i = 0; i < this.pointCount; i++) {\n                const bin = positions[this.textSprites[i]];\n                const { tl, br } = bin;\n                this._fillTextTexCoord(tl, br, width, height);\n            }\n            this.textSprites.dirty = false;\n        }\n\n        _initTexture(data, width, height) {\n            const config = {\n                data,\n                width,\n                height,\n                mag: 'linear',\n                min: 'linear',\n                premultiplyAlpha: true\n            };\n            if (this._clusterTexture) {\n                if (this._clusterTexture.update) {\n                    this._clusterTexture.update(config);\n                } else {\n                    this._clusterTexture(config);\n                }\n            } else {\n                this._clusterTexture = this.device.texture(config);\n            }\n            this._clusterMesh.setUniform('sourceTexture', this._clusterTexture);\n        }\n\n        _initTextTexture(data, width, height) {\n            const config = {\n                data,\n                width,\n                height,\n                mag: 'linear',\n                min: 'linear',\n                premultiplyAlpha: true\n            };\n            if (this._textTexture) {\n                if (this._textTexture.update) {\n                    this._textTexture.update(config);\n                } else {\n                    this._textTexture(config);\n                }\n            } else {\n                this._textTexture = this.device.texture(config);\n            }\n            this._textMesh.setUniform('sourceTexture', this._textTexture);\n        }\n\n        _fillTexCoord(tl, br, texWidth, texHeight) {\n            const u1 = tl[0] / texWidth;\n            const v1 = br[1] / texHeight;\n            const u2 = br[0] / texWidth;\n            const v2 = tl[1] / texHeight;\n\n            this.addVertexTexCoord(u1, v1);\n            this.addVertexTexCoord(u2, v1);\n            this.addVertexTexCoord(u1, v2);\n            this.addVertexTexCoord(u1, v2);\n            this.addVertexTexCoord(u2, v1);\n            this.addVertexTexCoord(u2, v2);\n        }\n\n        _fillTextTexCoord(tl, br, texWidth, texHeight) {\n            const u1 = tl[0] / texWidth;\n            const v1 = br[1] / texHeight;\n            const u2 = br[0] / texWidth;\n            const v2 = tl[1] / texHeight;\n\n            this.addTextTexCoord(u1, v1);\n            this.addTextTexCoord(u2, v1);\n            this.addTextTexCoord(u1, v2);\n            this.addTextTexCoord(u1, v2);\n            this.addTextTexCoord(u2, v1);\n            this.addTextTexCoord(u2, v2);\n        }\n\n        _genAtlas() {\n            if (!this.textureDirty) {\n                return this.atlas;\n            }\n            const { IconAtlas, RGBAImage } = getVectorPacker();\n            const icons = this.clusterSprites;\n            const iconMap = {};\n            for (const url in icons) {\n                const icon = icons[url];\n                const { width, height, data } = icon.data;\n                const image = new RGBAImage({ width, height }, data);\n                iconMap[url] = { data: image, pixelRatio: 1 };\n            }\n            const isWebGL1 = this.gl && (this.gl instanceof WebGLRenderingContext);\n            this.atlas = new IconAtlas(iconMap, { nonPowerOfTwo: !isWebGL1 });\n            this.textureDirty = false;\n            const { image } = this.atlas;\n            const { width, height } = image;\n            this._initTexture(image.data, width, height);\n            return this.atlas;\n        }\n\n        _genTextAtlas() {\n            if (!this.textTextureDirty) {\n                return this.textAtlas;\n            }\n            const { IconAtlas, RGBAImage } = getVectorPacker();\n            const texts = this.clusterTextSprites;\n            const textMap = {};\n            for (const key in texts) {\n                const textSprite = texts[key];\n                const { width, height, data } = textSprite.data;\n                const image = new RGBAImage({ width, height }, data);\n                textMap[key] = { data: image, pixelRatio: 1 };\n            }\n            const isWebGL1 = this.gl && (this.gl instanceof WebGLRenderingContext);\n            this.textAtlas = new IconAtlas(textMap, { nonPowerOfTwo: !isWebGL1 });\n            const { image } = this.textAtlas;\n            const { width, height } = image;\n            this._initTextTexture(image.data, width, height);\n            this.textTextureDirty = false;\n\n            const debugCanvas = document.getElementById('debug-text-atlas');\n            if (debugCanvas) {\n                debugCanvas.width = width;\n                debugCanvas.height = height;\n                const ctx = debugCanvas.getContext('2d');\n                ctx.putImageData(new ImageData(new Uint8ClampedArray(image.data.buffer), width, height), 0, 0);\n            }\n\n            return this.textAtlas;\n        }\n\n        addVertexTexCoord(u, v) {\n            const texCoordBufferData = this.texCoordBufferData;\n            if (texCoordBufferData[this.texCoordIndex] !== u) {\n                texCoordBufferData[this.texCoordIndex] = u;\n                texCoordBufferData.dirty = true;\n            }\n            this.texCoordIndex++;\n            if (texCoordBufferData[this.texCoordIndex] !== v) {\n                texCoordBufferData[this.texCoordIndex] = v;\n                texCoordBufferData.dirty = true;\n            }\n            this.texCoordIndex++;\n        }\n\n        addTextTexCoord(u, v) {\n            const textTexCoordData = this.textTexCoordData;\n            if (textTexCoordData[this.textTexCoordIndex] !== u) {\n                textTexCoordData[this.textTexCoordIndex] = u;\n                textTexCoordData.dirty = true;\n            }\n            this.textTexCoordIndex++;\n            if (textTexCoordData[this.textTexCoordIndex] !== v) {\n                textTexCoordData[this.textTexCoordIndex] = v;\n                textTexCoordData.dirty = true;\n            }\n            this.textTexCoordIndex++;\n        }\n\n        initContext() {\n            // this.\n            this._initClusterShader();\n            this._initClusterMeshes();\n            return super.initContext();\n        }\n\n        onRemove() {\n            if (this._spriteShader) {\n                this._spriteShader.dispose();\n                delete this._spriteShader;\n            }\n            if (this._clusterMesh) {\n                this._clusterMesh.dispose();\n                delete this._clusterMesh;\n            }\n            if (this._clusterGeometry) {\n                this._clusterGeometry.dispose();\n                delete this._clusterGeometry;\n            }\n            if (this._textMesh) {\n                this._textMesh.dispose();\n                delete this._textMesh;\n            }\n            if (this._textGeometry) {\n                this._textGeometry.dispose();\n                delete this._textGeometry;\n            }\n            if (this._clusterTexture) {\n                this._clusterTexture.destroy();\n                delete this._clusterTexture;\n            }\n            if (this._textTexture) {\n                this._textTexture.destroy();\n                delete this._textTexture;\n            }\n            return super.onRemove();\n        }\n\n        _initClusterShader() {\n            const viewport = {\n                x : 0,\n                y : 0,\n                width : () => {\n                    return this.canvas ? this.canvas.width : 1;\n                },\n                height : () => {\n                    return this.canvas ? this.canvas.height : 1;\n                }\n            };\n\n            const extraCommandProps = {\n                viewport,\n                depth: {\n                    enable: false\n                },\n                blend: {\n                    enable: true,\n                    func: {\n                        src: 1,\n                        dst: 'one minus src alpha'\n                    }\n                }\n            };\n\n            this._spriteShader = new reshader.MeshShader({\n                name: 'cluster-sprite',\n                vert,\n                frag,\n                wgslVert,\n                wgslFrag,\n                extraCommandProps\n            });\n        }\n\n        _initClusterMeshes() {\n            this.maxPointCount = 1024;\n            this.pointCount = 0;\n            this.clusterSprites = {};\n            this.clusterTextSprites = {};\n            this.sprites = [];\n            this.textSprites = [];\n            this.spriteCluster = [];\n\n            const {\n                positionBufferData, texCoordBufferData, opacityBufferData,\n                textPositionData, textTexCoordData\n            } = this._initBuffers();\n            this.positionBufferData = positionBufferData;\n            this.texCoordBufferData = texCoordBufferData;\n            this.opacityBufferData = opacityBufferData;\n            this.textPositionData = textPositionData;\n            this.textTexCoordData = textTexCoordData;\n\n            this._clusterGeometry = new reshader.Geometry({\n                aPosition: this.positionBufferData,\n                aTexCoord: this.texCoordBufferData,\n                aOpacity: this.opacityBufferData\n            }, null, 0, {\n                positionSize: 2\n            });\n            this._clusterGeometry.generateBuffers(this.device);\n            this._clusterMesh = new reshader.Mesh(this._clusterGeometry);\n            this._scene = new reshader.Scene([this._clusterMesh]);\n\n            this._textGeometry = new reshader.Geometry({\n                aPosition: this.textPositionData,\n                aTexCoord: this.textTexCoordData,\n                aOpacity: this.opacityBufferData\n            }, null, 0, {\n                positionSize: 2\n            });\n            this._textGeometry.generateBuffers(this.device);\n            this._textMesh = new reshader.Mesh(this._textGeometry);\n            this._textScene = new reshader.Scene([this._textMesh]);\n\n            this._renderer = new reshader.Renderer(this.device);\n        }\n\n        _initBuffers() {\n            const vertexSize = 2;\n            const texCoordSize = 2;\n            const opacitySize = 1;\n\n            const positionBufferData = new Float32Array(this.maxPointCount * vertexSize * 6);\n            const texCoordBufferData = new Float32Array(this.maxPointCount * texCoordSize * 6);\n            const opacityBufferData = new Float32Array(this.maxPointCount * opacitySize * 6);\n            // opacityBufferData.fill(255);\n\n            const textPositionData = new Float32Array(this.maxPointCount * vertexSize * 6);\n            const textTexCoordData = new Float32Array(this.maxPointCount * texCoordSize * 6);\n\n            return { positionBufferData, texCoordBufferData, opacityBufferData, textPositionData, textTexCoordData };\n        }\n\n        _getLayerOpacity() {\n            let layerOpacity = this.layer && this.layer.options['opacity'];\n            if (maptalks.Util.isNil(layerOpacity)) {\n                layerOpacity = 1;\n            }\n            return layerOpacity;\n        }\n    }\n    ClusterLayer.registerRenderer('gl', ClusterGLRenderer);\n    ClusterLayer.registerRenderer('gpu', ClusterGLRenderer);\n}\n\nfunction getSymbolStamp(symbol) {\n    const values = [];\n    for (const p in symbol) {\n        if (p[0] === '_') {\n            continue;\n        }\n        values.push(symbol[p]);\n    }\n    return values.join('|');\n}\n"],"names":["fontCtx","document","createElement","getContext","ZERO_POINT","maptalks","Point","MarkerLayerClazz","DrawToolLayer","markerLayerClazz","renderer","getRendererClass","options","maxClusterRadius","textSumProperty","symbol","drawClusterText","textSymbol","animation","animationDuration","maxClusterZoom","noClusterWithOneMarker","forceRenderOnZooming","ClusterLayer","fromJSON","json","layer","geoJSONs","geometries","i","length","geo","Geometry","push","addGeometry","addMarker","markers","this","len","Marker","Error","super","apply","arguments","onConfig","conf","_getRenderer","render","identify","coordinate","map","getMap","maxZoom","getZoom","toJSON","call","getClusters","_currentClusters","mergeOptions","registerJSONType","defaultTextSymbol","textFaceName","textSize","textDx","textDy","defaultSymbol","markerType","markerFill","property","type","stops","markerFillOpacity","markerLineOpacity","markerLineWidth","markerLineColor","markerWidth","markerHeight","ClusterLayerRenderable","Base","init","_refreshStyle","_clusterNeedRedraw","checkResources","resources","_symbolResourceChecked","res","Util","getExternalResources","draw","timestamp","parentContext","canvas","prepareCanvas","zoom","checkMarksToDraw","clusters","_clearDataCache","_computeGrid","_triggerAnimate","_startAnimation","_animateDelta","_animateClusters","zoomClusters","_clusterCache","getClustersToDraw","_drawLayer","_parentClusters","dr","_inout","_animating","_player","Animation","animate","d","speed","easing","frame","styles","state","playState","setToRedraw","play","dirty","_markersToDraw","_geoList","_isMarkersDirty","oldMarkersToDraw","font","StringUtil","getFont","_textSymbol","digitLen","stringLength","toPoint","extent","getContainerExtent","pt","pExt","sprite","width","height","markerIndex","isMarkerDirty","p","_currentGrid","marker","_cluster","_getSprite","_prjToContainerPoint","PointExtent","sub","add","intersects","text","_getClusterText","x","y","_multi","drawOnInteracting","args","drawClusters","getCurrentNeedRenderGeos","_getCurrentNeedRenderGeos","forEachGeo","fn","context","forEach","g","onGeometryShow","onGeometryHide","onGeometryAdd","onGeometryRemove","onGeometryPositionChange","onRemove","point","coordinateToContainerPoint","old","c","distanceTo","center","getProjection","unproject","copy","children","slice","_hitGeos","onSymbolChanged","_stopAnim","argFn","_symbol","MapboxUtil","loadFunctionTypes","drawClustersFrame","drawMarkers","completeRender","drawGeos","parentClusters","toClusters","ratio","drawn","key","drawCluster","z","r","_getResolution","min","_markerExtent","getMin","pkey","Math","floor","parent","pp","cluster","op","ctx","opacity","globalAlpha","pos","offset","_sub","Canvas","image","prepareCanvasFont","textBaseline","dx","dy","fillText","_add","_spriteCache","values","join","getSymbolStamp","CanvasClass","_initGridSystem","points","isVisible","_getPrjCoordinates","_combine","_getPrjExtent","id","_getInternalId","geometry","_markerPoints","pre","getMinZoom","getMaxZoom","getCount","_computeZoomGrid","preT","preCache","sumProperty","grids","gx","gy","pgx","pgy","sumProp","getProperties","Coordinate","multi","sum","count","_mergeClusters","clusterMap","merging","visited","c1","c2","gxgy","split","ii","iii","_distanceTo","m","grid","toMerge","concat","sqrt","finish","onZoomStart","param","onZoomEnd","isEmpty","_zoomInClusters","ClusterLayerRenderer","VectorLayerCanvasRenderer","constructor","registerRenderer","PointLayerRenderer","ClusterGLRenderer","event","_clearToDraw","flush","pointCount","bufferIndex","opacityIndex","textIndex","data","willReadFrequently","getImageData","clusterSprites","textureDirty","pixelRatio","getDevicePixelRatio","spriteW","spriteH","addPoint","fontKey","fillStyle","_getTextSprite","clusterTextSprites","textTextureDirty","addTextPoint","_textSpriteCache","dpr","metrics","measureText","textWidth","textHeight","actualBoundingBoxAscent","actualBoundingBoxDescent","scale","debugCanvas","getElementById","drawImage","_checkToRebuildGeometry","prototype","isInteractingOrAnimating","rebuildGeometries","isZooming","_updateMesh","fbo","renderTarget","_clusterGeometry","setDrawCount","uniforms","resolution","layerOpacity","_getLayerOpacity","dxDy","_renderer","_spriteShader","_scene","_textGeometry","_textScene","isAtlasDirty","atlas","_genAtlas","_updateTexCoord","textAtlas","_genTextAtlas","_updateTextTexCoord","_updateGeometryData","_check","w","h","addVertex","sprites","positionBufferData","opacityBufferData","addTextVertex","textSprites","textPositionData","maxPointCount","texCoordBufferData","textTexCoordData","_initBuffers","updateData","positions","texCoordIndex","bin","tl","br","_fillTexCoord","textTexCoordIndex","_fillTextTexCoord","_initTexture","config","mag","premultiplyAlpha","_clusterTexture","update","device","texture","_clusterMesh","setUniform","_initTextTexture","_textTexture","_textMesh","texWidth","texHeight","u1","v1","u2","v2","addVertexTexCoord","addTextTexCoord","IconAtlas","RGBAImage","getVectorPacker","icons","iconMap","url","icon","isWebGL1","gl","WebGLRenderingContext","nonPowerOfTwo","texts","textMap","textSprite","putImageData","ImageData","Uint8ClampedArray","buffer","u","v","initContext","_initClusterShader","_initClusterMeshes","dispose","destroy","extraCommandProps","viewport","depth","enable","blend","func","src","dst","reshader","MeshShader","name","vert","frag","wgslVert","wgslFrag","spriteCluster","aPosition","aTexCoord","aOpacity","positionSize","generateBuffers","Mesh","Scene","Renderer","Float32Array","isNil"],"mappings":"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"}