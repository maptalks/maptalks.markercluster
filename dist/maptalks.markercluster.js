/*!
 * maptalks.markercluster v0.9.1
 * LICENSE : MIT
 * (c) 2016-2025 maptalks.org
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("maptalks"),require("@maptalks/gl"),require("@maptalks/vt")):"function"==typeof define&&define.amd?define(["exports","maptalks","@maptalks/gl","@maptalks/vt"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).maptalks=t.maptalks||{},t.maptalks,t.maptalks,t.maptalks)}(this,function(t,e,r,i){"use strict";function s(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach(function(r){if("default"!==r){var i=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,i.get?i:{enumerable:!0,get:function(){return t[r]}})}}),e.default=t,Object.freeze(e)}var o=s(e);const a=document.createElement("canvas").getContext("2d"),n=new o.Point(0,0),h=o.DrawToolLayer.markerLayerClazz;let u="canvas";h.getRendererClass("canvas")||(u="gl");const d={"renderer":u,"maxClusterRadius":160,"textSumProperty":null,"symbol":null,"drawClusterText":!0,"textSymbol":null,"animation":!0,"animationDuration":450,"maxClusterZoom":null,"noClusterWithOneMarker":!0,"forceRenderOnZooming":!0};class l extends h{static fromJSON(t){if(!t||"ClusterLayer"!==t.type)return null;const e=new l(t.id,t.options),r=t.geometries,i=[];for(let t=0;t<r.length;t++){const e=o.Geometry.fromJSON(r[t]);e&&i.push(e)}return e.addGeometry(i),e}addMarker(t){return this.addGeometry(t)}addGeometry(t){for(let e=0,r=t.length;e<r;e++)if(!(t[e]instanceof o.Marker))throw new Error("Only a point(Marker) can be added into a ClusterLayer");return super.addGeometry.apply(this,arguments)}onConfig(t){if(super.onConfig(t),t.maxClusterRadius||t.symbol||t.drawClusterText||t.textSymbol||t.maxClusterZoom){const t=this._getRenderer();t&&t.render()}return this}identify(t,e){const r=this.getMap(),i=this.options.maxClusterZoom;return i&&r&&r.getZoom()>i?super.identify(t,e):this._getRenderer()?this._getRenderer().identify(t,e):null}toJSON(){const t=super.toJSON.call(this);return t.type="ClusterLayer",t}getClusters(){const t=this._getRenderer();return t&&t._currentClusters||[]}}l.mergeOptions(d),l.registerJSONType("ClusterLayer");const c={"textFaceName":'"microsoft yahei"',"textSize":16,"textDx":0,"textDy":0},x={"markerType":"ellipse","markerFill":{property:"count",type:"interval",stops:[[0,"rgb(135, 196, 240)"],[9,"#1bbc9b"],[99,"rgb(216, 115, 149)"]]},"markerFillOpacity":.7,"markerLineOpacity":1,"markerLineWidth":3,"markerLineColor":"#fff","markerWidth":{property:"count",type:"interval",stops:[[0,40],[9,60],[99,80]]},"markerHeight":{property:"count",type:"interval",stops:[[0,40],[9,60],[99,80]]}},p=function(t){return class extends t{init(){this._refreshStyle(),this._clusterNeedRedraw=!0}checkResources(){if(!super.checkResources)return[];const t=this.layer.options.symbol||x,e=super.checkResources.apply(this,arguments);if(t!==this._symbolResourceChecked){const r=o.Util.getExternalResources(t,!0);r&&e.push.apply(e,r),this._symbolResourceChecked=t}return e}draw(t,e){this.canvas||this.prepareCanvas();const r=this.getMap().getZoom(),i=this.layer.options.maxClusterZoom;if(i&&r>i)return delete this._currentClusters,this.checkMarksToDraw(),void super.draw.apply(this,arguments);let s;if(this._clusterNeedRedraw&&(this._clearDataCache(),this._computeGrid(),this._clusterNeedRedraw=!1),this._triggerAnimate&&this._startAnimation(r),this._animateDelta)s=this._animateClusters;else{const t=this._clusterCache[r]?this._clusterCache[r].clusters:null;s=this.getClustersToDraw(t),s.zoom=r}this._drawLayer(s,t,e)}_startAnimation(t){const e=this._clusterCache[t]?this._clusterCache[t].clusters:null,r=this.getClustersToDraw(e);r.zoom=t,this._animateClusters=r,this._parentClusters=this._currentClusters||r;const i=this.layer;if(i.options.animation&&this._triggerAnimate){let t=[0,1];"in"===this._inout&&(t=[1,0]),this._animateDelta=t[0],this._player=o.animation.Animation.animate({"d":t},{"speed":i.options.animationDuration,"easing":"inAndOut"},t=>{this._animateDelta=t.styles.d,"finished"===t.state.playState&&(delete this._animateDelta,delete this._inout,delete this._animateClusters,delete this._parentClusters),this.setToRedraw()}).play(),this.setToRedraw()}this._triggerAnimate=!1}checkMarksToDraw(){const t=this._markersToDraw!==this.layer._geoList;this._markersToDraw=this.layer._geoList,this._markersToDraw.dirty=t}getClustersToDraw(t){const e=this._markersToDraw||[];this._markersToDraw=[];const r=this.getMap(),i=o.StringUtil.getFont(this._textSymbol),s=o.StringUtil.stringLength("9",i).toPoint(),a=r.getContainerExtent(),n=[];let h,u,d,l,c,x=0,p=!1;for(const i in t){if(this._currentGrid=t[i],1===t[i].count&&this.layer.options.noClusterWithOneMarker){const r=t[i].children[0];r._cluster=t[i],p||e[x++]===r||(p=!0),this._markersToDraw.push(r);continue}if(d=this._getSprite().sprite,l=d.canvas.width,c=d.canvas.height,h=r._prjToContainerPoint(t[i].center),u=new o.PointExtent(h.sub(l,c),h.add(l,c)),a.intersects(u)){if(!t[i].textSize){const e=this._getClusterText(t[i]);t[i].textSize=new o.Point(s.x*e.length,s.y)._multi(.5)}n.push(t[i])}}return e.length!==this._markersToDraw.length&&(p=!0),this._markersToDraw.dirty=p,n}drawOnInteracting(...t){this._currentClusters&&this.drawClusters(this._currentClusters,1),super.drawOnInteracting(...t)}getCurrentNeedRenderGeos(){return this._markersToDraw?this._markersToDraw:[]}_getCurrentNeedRenderGeos(){return this.getCurrentNeedRenderGeos()}forEachGeo(t,e){this._markersToDraw&&this._markersToDraw.forEach(r=>{e?t.call(e,r):t(r)})}onGeometryShow(){this._clusterNeedRedraw=!0,super.onGeometryShow.apply(this,arguments)}onGeometryHide(){this._clusterNeedRedraw=!0,super.onGeometryHide.apply(this,arguments)}onGeometryAdd(){this._clusterNeedRedraw=!0,super.onGeometryAdd.apply(this,arguments)}onGeometryRemove(){this._clusterNeedRedraw=!0,super.onGeometryRemove.apply(this,arguments)}onGeometryPositionChange(){this._clusterNeedRedraw=!0,super.onGeometryPositionChange.apply(this,arguments)}onRemove(){this._clearDataCache()}identify(t,e){const r=this.getMap(),i=this.layer.options.maxClusterZoom;if(i&&r.getZoom()>i)return super.identify(t,e);if(this._currentClusters){const e=r.coordinateToContainerPoint(t),i=this._currentGrid;for(let t=0;t<this._currentClusters.length;t++){const i=this._currentClusters[t],s=r._prjToContainerPoint(i.center);this._currentGrid=i;const o=this._getSprite().sprite.canvas.width;if(e.distanceTo(s)<=o)return{"center":r.getProjection().unproject(i.center.copy()),"children":i.children.slice(0)}}this._currentGrid=i}if(this._markersToDraw&&this._markersToDraw[0]){const i=r.coordinateToContainerPoint(t);return this.layer._hitGeos(this._markersToDraw,i,e)}return null}onSymbolChanged(){this._refreshStyle(),this._computeGrid(),this._stopAnim(),this.setToRedraw()}_refreshStyle(){const t=this.layer.options.symbol||x,e=this.layer.options.textSymbol||c,r=()=>[this.getMap().getZoom(),this._currentGrid];this._symbol=o.MapboxUtil.loadFunctionTypes(t,r),this._textSymbol=o.MapboxUtil.loadFunctionTypes(e,r)}_drawLayer(t,e,r){this._currentClusters=t,this._animateDelta>=0?"in"===this._inout?this.drawClustersFrame(t,this._parentClusters,this._animateDelta):this.drawClustersFrame(this._parentClusters,t,this._animateDelta):this.drawClusters(t,1),this.drawMarkers(e,r),this.completeRender()}drawMarkers(){super.drawGeos()}drawClustersFrame(t,e,r){this.prepareCanvas();const i=this.getMap(),s={};if(t&&t.forEach(t=>{const e=i._prjToContainerPoint(t.center);s[t.key]||(s[t.key]=1,this.drawCluster(e,t,1-r))}),0===r||!e)return;const o=t.zoom,a=i._getResolution(o)*this.layer.options.maxClusterRadius,n=this._markerExtent.getMin();e.forEach(t=>{let e=i._prjToContainerPoint(t.center);const s=t.center,h=Math.floor((s.x-n.x)/a)+"_"+Math.floor((s.y-n.y)/a),u=this._clusterCache[o]?this._clusterCache[o].clusterMap[h]:null;if(u){const t=i._prjToContainerPoint(u.center);e=t.add(e.sub(t)._multi(r))}this.drawCluster(e,t,r>.5?1:r)})}drawClusters(t,e){if(!t)return;this.prepareCanvas();const r=this.getMap();t.forEach(t=>{const i=r._prjToContainerPoint(t.center);this.drawCluster(i,t,e>.5?1:e)})}drawCluster(t,e,r){this._currentGrid=e;const i=this.context,s=this._getSprite().sprite,a=i.globalAlpha;if(a*r!==0){if(i.globalAlpha=a*r,s){const e=t.add(s.offset)._sub(s.canvas.width/2,s.canvas.height/2);o.Canvas.image(i,s.canvas,e.x,e.y)}if(this.layer.options.drawClusterText&&e.textSize){o.Canvas.prepareCanvasFont(i,this._textSymbol),i.textBaseline="middle";const r=this._textSymbol.textDx||0,s=this._textSymbol.textDy||0,a=this._getClusterText(e);o.Canvas.fillText(i,a,t.sub(e.textSize.x,0)._add(r,s))}i.globalAlpha=a}}_getClusterText(t){return(this.layer.options.textSumProperty?t.textSumProperty:t.count)+""}_getSprite(){this._spriteCache||(this._spriteCache={});const t=function(t){const e=[];for(const r in t)"_"!==r[0]&&e.push(t[r]);return e.join("|")}(this._symbol);return this._spriteCache[t]||(this._spriteCache[t]=new o.Marker([0,0],{"symbol":this._symbol})._getSprite(this.resources,this.getMap().CanvasClass)),{sprite:this._spriteCache[t],key:t}}_initGridSystem(){const t=[];let e,r;this.layer.forEach(i=>{i.isVisible()&&(r=i._getPrjCoordinates(),e=e?e._combine(i._getPrjExtent()):i._getPrjExtent(),t.push({x:r.x,y:r.y,id:i._getInternalId(),geometry:i}))}),this._markerExtent=e,this._markerPoints=t}_computeGrid(){const t=this.getMap(),e=t.getZoom();this._markerExtent||this._initGridSystem(),this._clusterCache||(this._clusterCache={});const r=t._getResolution(t.getMinZoom())>t._getResolution(t.getMaxZoom())?e-1:e+1;this._clusterCache[r]&&this._clusterCache[r].length===this.layer.getCount()&&(this._clusterCache[e]=this._clusterCache[r]),this._clusterCache[e]||(this._clusterCache[e]=this._computeZoomGrid(e))}_computeZoomGrid(t){if(!this._markerExtent)return null;const e=this.getMap(),r=e._getResolution(t)*this.layer.options.maxClusterRadius,i=e._getResolution(t-1)?e._getResolution(t-1)*this.layer.options.maxClusterRadius:null;let s=this._clusterCache[t-1];!s&&t-1>=e.getMinZoom()&&(this._clusterCache[t-1]=s=this._computeZoomGrid(t-1));const a=this._markerPoints,n=this.layer.options.textSumProperty,h={},u=this._markerExtent.getMin();let d,l,c,x,p,y;for(let t=0,e=a.length;t<e;t++){const e=a[t].geometry;let m=0;n&&e.getProperties()&&e.getProperties()[n]&&(m=e.getProperties()[n]),d=Math.floor((a[t].x-u.x)/r),l=Math.floor((a[t].y-u.y)/r),c=d+"_"+l,h[c]?(h[c].sum._add(new o.Coordinate(a[t].x,a[t].y)),h[c].count++,h[c].center=h[c].sum.multi(1/h[c].count),h[c].children.push(e),h[c].textSumProperty+=m):(h[c]={"sum":new o.Coordinate(a[t].x,a[t].y),"center":new o.Coordinate(a[t].x,a[t].y),"count":1,"textSumProperty":m,"children":[e],"key":c+""},i&&s&&(x=Math.floor((a[t].x-u.x)/i),p=Math.floor((a[t].y-u.y)/i),y=x+"_"+p,h[c].parent=s.clusterMap[y]))}return this._mergeClusters(h,r/2)}_mergeClusters(t,e){const r={};for(const e in t)r[e]=t[e];const i={},s={};let o,a;for(const r in t){if(o=t[r],s[o.key])continue;const n=o.key.split("_"),h=+n[0],u=+n[1];for(let r=-1;r<=1;r++)for(let n=-1;n<=1;n++){if(0===r&&0===n)continue;a=t[h+r+"_"+(u+n)],a&&this._distanceTo(o.center,a.center)<=e&&(i[o.key]||(i[o.key]=[]),i[o.key].push(a),s[a.key]=1)}}for(const e in i){const s=t[e];if(!s)continue;const o=i[e];for(let e=0;e<o.length;e++)t[o[e].key]&&(s.sum._add(o[e].sum),s.count+=o[e].count,s.textSumProperty+=o[e].textSumProperty,s.children=s.children.concat(o[e].children),r[o[e].key]=s,delete t[o[e].key]);s.center=s.sum.multi(1/s.count)}return{"clusters":t,"clusterMap":r}}_distanceTo(t,e){const r=t.x-e.x,i=t.y-e.y;return Math.sqrt(r*r+i*i)}_stopAnim(){this._player&&"finished"!==this._player.playState&&this._player.finish()}onZoomStart(t){this._stopAnim(),super.onZoomStart(t)}onZoomEnd(t){!this.layer.isEmpty()&&this.layer.isVisible()?(this._inout=t.from>t.to?"in":"out",this._triggerAnimate=!0,this._computeGrid(),super.onZoomEnd.apply(this,arguments)):super.onZoomEnd.apply(this,arguments)}_clearDataCache(){this._stopAnim(),delete this._markerExtent,delete this._markerPoints,delete this._clusterCache,delete this._zoomInClusters}}};class y extends(p(o.renderer.VectorLayerCanvasRenderer)){constructor(...t){super(...t),this.init()}}if(l.registerRenderer("canvas",y),void 0!==i.PointLayerRenderer){class t extends(p(i.PointLayerRenderer)){constructor(...t){super(...t),this.init()}drawOnInteracting(t,e,r){this._currentClusters&&this.drawClusters(this._currentClusters,1),this.drawMarkers(e,r)}drawClusters(...t){this._clearToDraw(),super.drawClusters(...t),this.flush()}drawClustersFrame(...t){this._clearToDraw(),super.drawClustersFrame(...t),this.flush()}_clearToDraw(){this.pointCount=0,this.bufferIndex=0,this.opacityIndex=0,this.textIndex=0}drawCluster(t,e,r){this._currentGrid=e;const{sprite:i,key:s}=this._getSprite(),n=i.canvas;i.data||(i.data=n.getContext("2d",{willReadFrequently:!0}).getImageData(0,0,n.width,n.height)),this.clusterSprites[s]||(this.clusterSprites[s]=i,this.textureDirty=!0);const h=t.add(i.offset)._sub(n.width/2,n.height/2);let u=h.x,d=h.y;const l=this.getMap(),c=l.getDevicePixelRatio();u*=c,d=(l.height-d)*c;const x=i.data.width*c,p=i.data.height*c;if(this.addPoint(u,d,x,p,r,s),this.layer.options.drawClusterText){o.Canvas.prepareCanvasFont(a,this._textSymbol);const t=a.font+"-"+a.fillStyle,r=this._getClusterText(e),{sprite:i,key:s}=this._getTextSprite(r,t);this.clusterTextSprites[s]||(this.clusterTextSprites[s]=i,this.textTextureDirty=!0),this.addTextPoint(u+x/2,d-p/2,i.data.width*c,i.data.height*c,s)}this.pointCount++}_getTextSprite(t,e){this._textSpriteCache||(this._textSpriteCache={});const r=e+"-"+t;if(!this._textSpriteCache[r]){const e=this.getMap().getDevicePixelRatio(),i=a.measureText(t),s=i.width,h=i.actualBoundingBoxAscent+i.actualBoundingBoxDescent,u=document.createElement("canvas");u.width=s*e,u.height=h*e;const d=u.getContext("2d",{willReadFrequently:!0});d.scale(e,e),o.Canvas.prepareCanvasFont(d,this._textSymbol),d.textBaseline="top",d.fillText(t,0,0);const l=document.getElementById("debug-text-sprite");if(l){l.width=u.width,l.height=u.height;l.getContext("2d").drawImage(u,0,0)}this._textSpriteCache[r]={canvas:u,offset:n,data:d.getImageData(0,0,u.width,u.height)}}return{sprite:this._textSpriteCache[r],key:r}}checkMarksToDraw(){super.checkMarksToDraw(),this._checkToRebuildGeometry()}drawMarkers(t,e){this._checkToRebuildGeometry(),i.PointLayerRenderer.prototype.draw.call(this,t,e)}_checkToRebuildGeometry(){this._markersToDraw.dirty&&!this.isInteractingOrAnimating()&&(this.rebuildGeometries(),this._markersToDraw.dirty=!1)}isInteractingOrAnimating(){return this.getMap().isInteracting()||this._animateDelta>=0}flush(t){if(0===this.pointCount)return;this._updateMesh();const e=t&&t.renderTarget&&context.renderTarget.fbo;this._clusterGeometry.setDrawCount(6*this.pointCount);const{width:r,height:i}=this.canvas,s={resolution:[r,i],layerOpacity:this._getLayerOpacity(),dxDy:[0,0]};if(this._renderer.render(this._spriteShader,s,this._scene,e),this.layer.options.drawClusterText){this._textGeometry.setDrawCount(6*this.pointCount);const t=this._textSymbol.textDx||0,r=this._textSymbol.textDy||0;s.dxDy=[t,r],this._renderer.render(this._spriteShader,s,this._textScene,e)}}_updateMesh(){const t=this.textureDirty,e=this._genAtlas();if(this._updateTexCoord(e,t),this.layer.options.drawClusterText){const t=this.textTextureDirty,e=this._genTextAtlas();this._updateTextTexCoord(e,t)}this._updateGeometryData()}addPoint(t,e,r,i,s,o){this._check();const a=r,n=i;this.addVertex(t,e-n,s),this.addVertex(t+a,e-n,s),this.addVertex(t,e,s),this.addVertex(t,e,s),this.addVertex(t+a,e-n,s),this.addVertex(t+a,e,s),this.sprites[this.pointCount]!==o&&(this.sprites[this.pointCount]=o,this.sprites.dirty=!0)}addVertex(t,e,r){const i=this.positionBufferData;i[this.bufferIndex]!==t&&(i[this.bufferIndex]=t,i.dirty=!0),this.bufferIndex++,i[this.bufferIndex]!==e&&(i[this.bufferIndex]=e,i.dirty=!0),this.bufferIndex++;const s=this.opacityBufferData;s[this.opacityIndex]!==r&&(s[this.opacityIndex]=r,s.dirty=!0),this.opacityIndex++}addTextPoint(t,e,r,i,s){this._check();const o=this.getMap().getDevicePixelRatio(),a=(r/=o)/2,n=(i/=o)/2;this.addTextVertex(t-a,e-n),this.addTextVertex(t+a,e-n),this.addTextVertex(t-a,e+n),this.addTextVertex(t-a,e+n),this.addTextVertex(t+a,e-n),this.addTextVertex(t+a,e+n),this.textSprites[this.pointCount]!==s&&(this.textSprites[this.pointCount]=s,this.textSprites.dirty=!0)}addTextVertex(t,e){const r=this.textPositionData;r[this.textIndex]!==t&&(r[this.textIndex]=t,r.dirty=!0),this.textIndex++,r[this.textIndex]!==e&&(r[this.textIndex]=e,r.dirty=!0),this.textIndex++}_check(){if(this.pointCount>=this.maxPointCount-1){this.maxPointCount+=1024;const{positionBufferData:t,texCoordBufferData:e,opacityBufferData:r,textPositionData:i,textTexCoordData:s}=this._initBuffers();for(let r=0;r<this.bufferIndex;r++)t[r]=this.positionBufferData[r],e[r]=this.texCoordBufferData[r],i[r]=this.textPositionData[r],s[r]=this.textTexCoordData[r];for(let t=0;t<this.opacityIndex;t++)r[t]=this.opacityBufferData[t];this.positionBufferData=t,this.texCoordBufferData=e,this.opacityBufferData=r,this.textPositionData=i,this.textTexCoordData=s}}_updateGeometryData(){this.positionBufferData.dirty&&(this._clusterGeometry.updateData("aPosition",this.positionBufferData),this.positionBufferData.dirty=!1),this.opacityBufferData.dirty&&(this._clusterGeometry.updateData("aOpacity",this.opacityBufferData),this._textGeometry.updateData("aOpacity",this.opacityBufferData),this.opacityBufferData.dirty=!1),this.texCoordBufferData.dirty&&(this._clusterGeometry.updateData("aTexCoord",this.texCoordBufferData),this.texCoordBufferData.dirty=!1),this.textPositionData.dirty&&(this._textGeometry.updateData("aPosition",this.textPositionData),this.textPositionData.dirty=!1),this.textTexCoordData.dirty&&(this._textGeometry.updateData("aTexCoord",this.textTexCoordData),this.textTexCoordData.dirty=!1)}_updateTexCoord(t,e){if(!this.sprites.dirty&&!e)return;const{positions:r,image:i}=t,{width:s,height:o}=i;this.texCoordIndex=0;for(let t=0;t<this.pointCount;t++){const e=r[this.sprites[t]],{tl:i,br:a}=e;this._fillTexCoord(i,a,s,o)}this.sprites.dirty=!1}_updateTextTexCoord(t,e){if(!this.textSprites.dirty&&!e)return;const{positions:r,image:i}=t,{width:s,height:o}=i;this.textTexCoordIndex=0;for(let t=0;t<this.pointCount;t++){const e=r[this.textSprites[t]],{tl:i,br:a}=e;this._fillTextTexCoord(i,a,s,o)}this.textSprites.dirty=!1}_initTexture(t,e,r){const i={data:t,width:e,height:r,mag:"linear",min:"linear",premultiplyAlpha:!0};this._clusterTexture?this._clusterTexture.update?this._clusterTexture.update(i):this._clusterTexture(i):this._clusterTexture=this.device.texture(i),this._clusterMesh.setUniform("sourceTexture",this._clusterTexture)}_initTextTexture(t,e,r){const i={data:t,width:e,height:r,mag:"linear",min:"linear",premultiplyAlpha:!0};this._textTexture?this._textTexture.update?this._textTexture.update(i):this._textTexture(i):this._textTexture=this.device.texture(i),this._textMesh.setUniform("sourceTexture",this._textTexture)}_fillTexCoord(t,e,r,i){const s=t[0]/r,o=e[1]/i,a=e[0]/r,n=t[1]/i;this.addVertexTexCoord(s,o),this.addVertexTexCoord(a,o),this.addVertexTexCoord(s,n),this.addVertexTexCoord(s,n),this.addVertexTexCoord(a,o),this.addVertexTexCoord(a,n)}_fillTextTexCoord(t,e,r,i){const s=t[0]/r,o=e[1]/i,a=e[0]/r,n=t[1]/i;this.addTextTexCoord(s,o),this.addTextTexCoord(a,o),this.addTextTexCoord(s,n),this.addTextTexCoord(s,n),this.addTextTexCoord(a,o),this.addTextTexCoord(a,n)}_genAtlas(){if(!this.textureDirty)return this.atlas;const{IconAtlas:t,RGBAImage:e}=i.getVectorPacker(),r=this.clusterSprites,s={};for(const t in r){const i=r[t],{width:o,height:a,data:n}=i.data,h=new e({width:o,height:a},n);s[t]={data:h,pixelRatio:1}}const o=this.gl&&this.gl instanceof WebGLRenderingContext;this.atlas=new t(s,{nonPowerOfTwo:!o}),this.textureDirty=!1;const{image:a}=this.atlas,{width:n,height:h}=a;return this._initTexture(a.data,n,h),this.atlas}_genTextAtlas(){if(!this.textTextureDirty)return this.textAtlas;const{IconAtlas:t,RGBAImage:e}=i.getVectorPacker(),r=this.clusterTextSprites,s={};for(const t in r){const i=r[t],{width:o,height:a,data:n}=i.data,h=new e({width:o,height:a},n);s[t]={data:h,pixelRatio:1}}const o=this.gl&&this.gl instanceof WebGLRenderingContext;this.textAtlas=new t(s,{nonPowerOfTwo:!o});const{image:a}=this.textAtlas,{width:n,height:h}=a;this._initTextTexture(a.data,n,h),this.textTextureDirty=!1;const u=document.getElementById("debug-text-atlas");if(u){u.width=n,u.height=h;u.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(a.data.buffer),n,h),0,0)}return this.textAtlas}addVertexTexCoord(t,e){const r=this.texCoordBufferData;r[this.texCoordIndex]!==t&&(r[this.texCoordIndex]=t,r.dirty=!0),this.texCoordIndex++,r[this.texCoordIndex]!==e&&(r[this.texCoordIndex]=e,r.dirty=!0),this.texCoordIndex++}addTextTexCoord(t,e){const r=this.textTexCoordData;r[this.textTexCoordIndex]!==t&&(r[this.textTexCoordIndex]=t,r.dirty=!0),this.textTexCoordIndex++,r[this.textTexCoordIndex]!==e&&(r[this.textTexCoordIndex]=e,r.dirty=!0),this.textTexCoordIndex++}initContext(){return this._initClusterShader(),this._initClusterMeshes(),super.initContext()}onRemove(){return this._spriteShader&&(this._spriteShader.dispose(),delete this._spriteShader),this._clusterMesh&&(this._clusterMesh.dispose(),delete this._clusterMesh),this._clusterGeometry&&(this._clusterGeometry.dispose(),delete this._clusterGeometry),this._textMesh&&(this._textMesh.dispose(),delete this._textMesh),this._textGeometry&&(this._textGeometry.dispose(),delete this._textGeometry),this._clusterTexture&&(this._clusterTexture.destroy(),delete this._clusterTexture),this._textTexture&&(this._textTexture.destroy(),delete this._textTexture),super.onRemove()}_initClusterShader(){const t={viewport:{x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1},depth:{enable:!1},blend:{enable:!0,func:{src:1,dst:"one minus src alpha"}}};this._spriteShader=new r.reshader.MeshShader({name:"cluster-sprite",vert:"attribute vec2 aPosition;\nattribute vec2 aTexCoord;\nattribute float aOpacity;\nuniform vec2 resolution;\nuniform vec2 dxDy;\nvarying vec2 vTexCoord;\nvarying float vOpacity;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vOpacity = aOpacity;\n    vec2 position = (aPosition + dxDy) / resolution * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}",frag:"precision mediump float;\nuniform sampler2D sourceTexture;\nuniform float layerOpacity;\nvarying vec2 vTexCoord;\nvarying float vOpacity;\nvoid main() {\n    vec4 color = texture2D(sourceTexture, vTexCoord);\n    gl_FragColor = color * vOpacity * layerOpacity;\n}",wgslVert:"struct VertexInput {\n  @location($i) aPosition: vec2f,\n  @location($i) aTexCoord: vec2f,\n  @location($i) aOpacity: f32,\n};\nstruct VertexOutput {\n  @builtin(position) Position: vec4f,\n  @location($o) vTexCoord: vec2f,\n  @location($o) vOpacity: f32,\n};\nstruct MyAppUniforms {\n  resolution: vec2f,\n  dxDy: vec2f,\n};\n@group(0) @binding($b) var<uniform> uniforms: MyAppUniforms;\n@vertex\nfn main(vertexInput: VertexInput) -> VertexOutput {\n  var output: VertexOutput;\n  output.vTexCoord = vertexInput.aTexCoord;\n  output.vOpacity = vertexInput.aOpacity;\n  let position = (vertexInput.aPosition + uniforms.dxDy) / uniforms.resolution * 2.0 - 1.0;\n  output.Position = vec4f(position, 0.0, 1.0);\n  return output;\n}",wgslFrag:"struct FragmentInput {\n  @location($i) vTexCoord: vec2f,\n  @location($i) vOpacity: f32,\n};\nstruct MyAppUniforms {\n  layerOpacity: f32,\n};\n@group(0) @binding($b) var<uniform> uniforms: MyAppUniforms;\n@group(0) @binding($b) var sourceTexture: texture_2d<f32>;\n@group(0) @binding($b) var sourceTextureSampler: sampler;\n@fragment\nfn main(fragmentInput: FragmentInput) -> @location(0) vec4f {\n  let color = textureSample(sourceTexture, sourceTextureSampler, fragmentInput.vTexCoord);\n  return color * fragmentInput.vOpacity * uniforms.layerOpacity;\n}",extraCommandProps:t})}_initClusterMeshes(){this.maxPointCount=1024,this.pointCount=0,this.clusterSprites={},this.clusterTextSprites={},this.sprites=[],this.textSprites=[],this.spriteCluster=[];const{positionBufferData:t,texCoordBufferData:e,opacityBufferData:i,textPositionData:s,textTexCoordData:o}=this._initBuffers();this.positionBufferData=t,this.texCoordBufferData=e,this.opacityBufferData=i,this.textPositionData=s,this.textTexCoordData=o,this._clusterGeometry=new r.reshader.Geometry({aPosition:this.positionBufferData,aTexCoord:this.texCoordBufferData,aOpacity:this.opacityBufferData},null,0,{positionSize:2}),this._clusterGeometry.generateBuffers(this.device),this._clusterMesh=new r.reshader.Mesh(this._clusterGeometry),this._scene=new r.reshader.Scene([this._clusterMesh]),this._textGeometry=new r.reshader.Geometry({aPosition:this.textPositionData,aTexCoord:this.textTexCoordData,aOpacity:this.opacityBufferData},null,0,{positionSize:2}),this._textGeometry.generateBuffers(this.device),this._textMesh=new r.reshader.Mesh(this._textGeometry),this._textScene=new r.reshader.Scene([this._textMesh]),this._renderer=new r.reshader.Renderer(this.device)}_initBuffers(){return{positionBufferData:new Float32Array(2*this.maxPointCount*6),texCoordBufferData:new Float32Array(2*this.maxPointCount*6),opacityBufferData:new Float32Array(1*this.maxPointCount*6),textPositionData:new Float32Array(2*this.maxPointCount*6),textTexCoordData:new Float32Array(2*this.maxPointCount*6)}}_getLayerOpacity(){let t=this.layer&&this.layer.options.opacity;return o.Util.isNil(t)&&(t=1),t}}l.registerRenderer("gl",t),l.registerRenderer("gpu",t)}t.ClusterLayer=l,Object.defineProperty(t,"__esModule",{value:!0}),"undefined"!=typeof console&&console.log("maptalks.markercluster v0.9.1")});
//# sourceMappingURL=maptalks.markercluster.js.map
