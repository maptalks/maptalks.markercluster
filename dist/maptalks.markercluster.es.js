/*!
 * maptalks.markercluster v0.9.3
 * LICENSE : MIT
 * (c) 2016-2025 maptalks.org
 */
import*as t from"maptalks";import{reshader as e}from"@maptalks/gl";import{PointLayerRenderer as i,getVectorPacker as r}from"@maptalks/vt";const s=document.createElement("canvas").getContext("2d"),o=new t.Point(0,0),a=t.DrawToolLayer.markerLayerClazz;let n="canvas";a.getRendererClass("canvas")||(n="gl");const h={"renderer":n,"maxClusterRadius":160,"textSumProperty":null,"symbol":null,"drawClusterText":!0,"textSymbol":null,"animation":!0,"animationDuration":450,"maxClusterZoom":null,"noClusterWithOneMarker":!0,"forceRenderOnZooming":!0};class u extends a{static fromJSON(e){if(!e||"ClusterLayer"!==e.type)return null;const i=new u(e.id,e.options),r=e.geometries,s=[];for(let e=0;e<r.length;e++){const i=t.Geometry.fromJSON(r[e]);i&&s.push(i)}return i.addGeometry(s),i}addMarker(t){return this.addGeometry(t)}addGeometry(e){for(let i=0,r=e.length;i<r;i++)if(!(e[i]instanceof t.Marker))throw new Error("Only a point(Marker) can be added into a ClusterLayer");return super.addGeometry.apply(this,arguments)}onConfig(t){if(super.onConfig(t),t.maxClusterRadius||t.symbol||t.drawClusterText||t.textSymbol||t.maxClusterZoom){const t=this._getRenderer();t&&t.render()}return this}identify(t,e){const i=this.getMap(),r=this.options.maxClusterZoom;return r&&i&&i.getZoom()>r?super.identify(t,e):this._getRenderer()?this._getRenderer().identify(t,e):null}toJSON(){const t=super.toJSON.call(this);return t.type="ClusterLayer",t}getClusters(){const t=this._getRenderer();return t&&t._currentClusters||[]}}u.mergeOptions(h),u.registerJSONType("ClusterLayer");const d={"textFaceName":'"microsoft yahei"',"textSize":16,"textDx":0,"textDy":0},l={"markerType":"ellipse","markerFill":{property:"count",type:"interval",stops:[[0,"rgb(135, 196, 240)"],[9,"#1bbc9b"],[99,"rgb(216, 115, 149)"]]},"markerFillOpacity":.7,"markerLineOpacity":1,"markerLineWidth":3,"markerLineColor":"#fff","markerWidth":{property:"count",type:"interval",stops:[[0,40],[9,60],[99,80]]},"markerHeight":{property:"count",type:"interval",stops:[[0,40],[9,60],[99,80]]}},c=function(e){return class extends e{init(){this._refreshStyle(),this._clusterNeedRedraw=!0}checkResources(){if(!super.checkResources)return[];const e=this.layer.options.symbol||l,i=super.checkResources.apply(this,arguments);if(e!==this._symbolResourceChecked){const r=t.Util.getExternalResources(e,!0);r&&i.push.apply(i,r),this._symbolResourceChecked=e}return i}draw(t,e){this.canvas||this.prepareCanvas();const i=this.getMap().getZoom(),r=this.layer.options.maxClusterZoom;if(r&&i>r)return delete this._currentClusters,this.checkMarksToDraw(),void super.draw.apply(this,arguments);let s;if(this._clusterNeedRedraw&&(this._clearDataCache(),this._computeGrid(),this._clusterNeedRedraw=!1),this._triggerAnimate&&this._startAnimation(i),this._animateDelta)s=this._animateClusters;else{const t=this._clusterCache[i]?this._clusterCache[i].clusters:null;s=this.getClustersToDraw(t),s.zoom=i}this._drawLayer(s,t,e)}_startAnimation(e){const i=this._clusterCache[e]?this._clusterCache[e].clusters:null,r=this.getClustersToDraw(i);r.zoom=e,this._animateClusters=r,this._parentClusters=this._currentClusters||r;const s=this.layer;if(s.options.animation&&this._triggerAnimate){let e=[0,1];"in"===this._inout&&(e=[1,0]),this._animateDelta=e[0],this._animating=!0,this._player=t.animation.Animation.animate({"d":e},{"speed":s.options.animationDuration,"easing":"inAndOut"},t=>{this._animateDelta=t.styles.d,"finished"===t.state.playState&&(delete this._animateDelta,delete this._inout,delete this._animateClusters,delete this._parentClusters,delete this._animating),this.setToRedraw()}).play(),this.setToRedraw()}this._triggerAnimate=!1}checkMarksToDraw(){const t=this._markersToDraw!==this.layer._geoList;this._markersToDraw=this.layer._geoList,this._isMarkersDirty=t}getClustersToDraw(e){const i=this._markersToDraw||[];this._markersToDraw=[];const r=this.getMap(),s=t.StringUtil.getFont(this._textSymbol),o=t.StringUtil.stringLength("9",s).toPoint(),a=r.getContainerExtent(),n=[];let h,u,d,l,c,x=0,p=!1;for(const s in e){if(this._currentGrid=e[s],1===e[s].count&&this.layer.options.noClusterWithOneMarker){const t=e[s].children[0];t._cluster=e[s],p||i[x++]===t||(p=!0),this._markersToDraw.push(t);continue}if(d=this._getSprite().sprite,l=d.canvas.width,c=d.canvas.height,h=r._prjToContainerPoint(e[s].center),u=new t.PointExtent(h.sub(l,c),h.add(l,c)),a.intersects(u)){if(!e[s].textSize){const i=this._getClusterText(e[s]);e[s].textSize=new t.Point(o.x*i.length,o.y)._multi(.5)}n.push(e[s])}}return i.length!==this._markersToDraw.length&&(p=!0),this._isMarkersDirty=this._isMarkersDirty||p,n}drawOnInteracting(...t){this._currentClusters&&this.drawClusters(this._currentClusters,1),super.drawOnInteracting(...t)}getCurrentNeedRenderGeos(){return this._markersToDraw?this._markersToDraw:[]}_getCurrentNeedRenderGeos(){return this.getCurrentNeedRenderGeos()}forEachGeo(t,e){this._markersToDraw&&this._markersToDraw.forEach(i=>{e?t.call(e,i):t(i)})}onGeometryShow(){this._clusterNeedRedraw=!0,super.onGeometryShow.apply(this,arguments)}onGeometryHide(){this._clusterNeedRedraw=!0,super.onGeometryHide.apply(this,arguments)}onGeometryAdd(){this._clusterNeedRedraw=!0,super.onGeometryAdd.apply(this,arguments)}onGeometryRemove(){this._clusterNeedRedraw=!0,super.onGeometryRemove.apply(this,arguments)}onGeometryPositionChange(){this._clusterNeedRedraw=!0,super.onGeometryPositionChange.apply(this,arguments)}onRemove(){this._clearDataCache()}identify(t,e){const i=this.getMap(),r=this.layer.options.maxClusterZoom;if(r&&i.getZoom()>r)return super.identify(t,e);if(this._currentClusters){const e=i.coordinateToContainerPoint(t),r=this._currentGrid;for(let t=0;t<this._currentClusters.length;t++){const r=this._currentClusters[t],s=i._prjToContainerPoint(r.center);this._currentGrid=r;const o=this._getSprite().sprite.canvas.width;if(e.distanceTo(s)<=o)return{"center":i.getProjection().unproject(r.center.copy()),"children":r.children.slice(0)}}this._currentGrid=r}if(this._markersToDraw&&this._markersToDraw[0]){const r=i.coordinateToContainerPoint(t);return this.layer._hitGeos(this._markersToDraw,r,e)}return null}onSymbolChanged(){this._refreshStyle(),this._computeGrid(),this._stopAnim(),this.setToRedraw()}_refreshStyle(){const e=this.layer.options.symbol||l,i=this.layer.options.textSymbol||d,r=()=>[this.getMap().getZoom(),this._currentGrid];this._symbol=t.MapboxUtil.loadFunctionTypes(e,r),this._textSymbol=t.MapboxUtil.loadFunctionTypes(i,r)}_drawLayer(t,e,i){this._currentClusters=t,this._animateDelta>=0?"in"===this._inout?this.drawClustersFrame(t,this._parentClusters,this._animateDelta):this.drawClustersFrame(this._parentClusters,t,this._animateDelta):this.drawClusters(t,1),this.drawMarkers(e,i),this.completeRender()}drawMarkers(){super.drawGeos()}drawClustersFrame(t,e,i){this.prepareCanvas();const r=this.getMap(),s={};if(t&&t.forEach(t=>{const e=r._prjToContainerPoint(t.center);s[t.key]||(s[t.key]=1,this.drawCluster(e,t,1-i))}),0===i||!e)return;const o=t.zoom,a=r._getResolution(o)*this.layer.options.maxClusterRadius,n=this._markerExtent.getMin();e.forEach(t=>{let e=r._prjToContainerPoint(t.center);const s=t.center,h=Math.floor((s.x-n.x)/a)+"_"+Math.floor((s.y-n.y)/a),u=this._clusterCache[o]?this._clusterCache[o].clusterMap[h]:null;if(u){const t=r._prjToContainerPoint(u.center);e=t.add(e.sub(t)._multi(i))}this.drawCluster(e,t,i>.5?1:i)})}drawClusters(t,e){if(!t)return;this.prepareCanvas();const i=this.getMap();t.forEach(t=>{const r=i._prjToContainerPoint(t.center);this.drawCluster(r,t,e>.5?1:e)})}drawCluster(e,i,r){this._currentGrid=i;const s=this.context,o=this._getSprite().sprite,a=s.globalAlpha;if(a*r!==0){if(s.globalAlpha=a*r,o){const i=e.add(o.offset)._sub(o.canvas.width/2,o.canvas.height/2);t.Canvas.image(s,o.canvas,i.x,i.y)}if(this.layer.options.drawClusterText&&i.textSize){t.Canvas.prepareCanvasFont(s,this._textSymbol),s.textBaseline="middle";const r=this._textSymbol.textDx||0,o=this._textSymbol.textDy||0,a=this._getClusterText(i);t.Canvas.fillText(s,a,e.sub(i.textSize.x,0)._add(r,o))}s.globalAlpha=a}}_getClusterText(t){return(this.layer.options.textSumProperty?t.textSumProperty:t.count)+""}_getSprite(){this._spriteCache||(this._spriteCache={});const e=function(t){const e=[];for(const i in t)"_"!==i[0]&&e.push(t[i]);return e.join("|")}(this._symbol);return this._spriteCache[e]||(this._spriteCache[e]=new t.Marker([0,0],{"symbol":this._symbol})._getSprite(this.resources,this.getMap().CanvasClass)),{sprite:this._spriteCache[e],key:e}}_initGridSystem(){const t=[];let e,i;this.layer.forEach(r=>{r.isVisible()&&(i=r._getPrjCoordinates(),e=e?e._combine(r._getPrjExtent()):r._getPrjExtent(),t.push({x:i.x,y:i.y,id:r._getInternalId(),geometry:r}))}),this._markerExtent=e,this._markerPoints=t}_computeGrid(){const t=this.getMap(),e=t.getZoom();this._markerExtent||this._initGridSystem(),this._clusterCache||(this._clusterCache={});const i=t._getResolution(t.getMinZoom())>t._getResolution(t.getMaxZoom())?e-1:e+1;this._clusterCache[i]&&this._clusterCache[i].length===this.layer.getCount()&&(this._clusterCache[e]=this._clusterCache[i]),this._clusterCache[e]||(this._clusterCache[e]=this._computeZoomGrid(e))}_computeZoomGrid(e){if(!this._markerExtent)return null;const i=this.getMap(),r=i._getResolution(e)*this.layer.options.maxClusterRadius,s=i._getResolution(e-1)?i._getResolution(e-1)*this.layer.options.maxClusterRadius:null;let o=this._clusterCache[e-1];!o&&e-1>=i.getMinZoom()&&(this._clusterCache[e-1]=o=this._computeZoomGrid(e-1));const a=this._markerPoints,n=this.layer.options.textSumProperty,h={},u=this._markerExtent.getMin();let d,l,c,x,p,y;for(let e=0,i=a.length;e<i;e++){const i=a[e].geometry;let _=0;n&&i.getProperties()&&i.getProperties()[n]&&(_=i.getProperties()[n]),d=Math.floor((a[e].x-u.x)/r),l=Math.floor((a[e].y-u.y)/r),c=d+"_"+l,h[c]?(h[c].sum._add(new t.Coordinate(a[e].x,a[e].y)),h[c].count++,h[c].center=h[c].sum.multi(1/h[c].count),h[c].children.push(i),h[c].textSumProperty+=_):(h[c]={"sum":new t.Coordinate(a[e].x,a[e].y),"center":new t.Coordinate(a[e].x,a[e].y),"count":1,"textSumProperty":_,"children":[i],"key":c+""},s&&o&&(x=Math.floor((a[e].x-u.x)/s),p=Math.floor((a[e].y-u.y)/s),y=x+"_"+p,h[c].parent=o.clusterMap[y]))}return this._mergeClusters(h,r/2)}_mergeClusters(t,e){const i={};for(const e in t)i[e]=t[e];const r={},s={};let o,a;for(const i in t){if(o=t[i],s[o.key])continue;const n=o.key.split("_"),h=+n[0],u=+n[1];for(let i=-1;i<=1;i++)for(let n=-1;n<=1;n++){if(0===i&&0===n)continue;a=t[h+i+"_"+(u+n)],a&&this._distanceTo(o.center,a.center)<=e&&(r[o.key]||(r[o.key]=[]),r[o.key].push(a),s[a.key]=1)}}for(const e in r){const s=t[e];if(!s)continue;const o=r[e];for(let e=0;e<o.length;e++)t[o[e].key]&&(s.sum._add(o[e].sum),s.count+=o[e].count,s.textSumProperty+=o[e].textSumProperty,s.children=s.children.concat(o[e].children),i[o[e].key]=s,delete t[o[e].key]);s.center=s.sum.multi(1/s.count)}return{"clusters":t,"clusterMap":i}}_distanceTo(t,e){const i=t.x-e.x,r=t.y-e.y;return Math.sqrt(i*i+r*r)}_stopAnim(){this._player&&"finished"!==this._player.playState&&this._player.finish()}onZoomStart(t){this._stopAnim(),super.onZoomStart(t)}onZoomEnd(t){!this.layer.isEmpty()&&this.layer.isVisible()?(this._inout=t.from>t.to?"in":"out",this._triggerAnimate=!0,this._computeGrid(),super.onZoomEnd.apply(this,arguments)):super.onZoomEnd.apply(this,arguments)}_clearDataCache(){this._stopAnim(),delete this._markerExtent,delete this._markerPoints,delete this._clusterCache,delete this._zoomInClusters}}};class x extends(c(t.renderer.VectorLayerCanvasRenderer)){constructor(...t){super(...t),this.init()}}if(u.registerRenderer("canvas",x),void 0!==i){class a extends(c(i)){constructor(...t){super(...t),this.init()}drawOnInteracting(t,e,i){this._currentClusters&&this.drawClusters(this._currentClusters,1),this.drawMarkers(e,i)}drawClusters(...t){this._clearToDraw(),super.drawClusters(...t),this.flush()}drawClustersFrame(...t){this._clearToDraw(),super.drawClustersFrame(...t),this.flush()}_clearToDraw(){this.pointCount=0,this.bufferIndex=0,this.opacityIndex=0,this.textIndex=0}drawCluster(e,i,r){this._currentGrid=i;const{sprite:o,key:a}=this._getSprite(),n=o.canvas;o.data||(o.data=n.getContext("2d",{willReadFrequently:!0}).getImageData(0,0,n.width,n.height)),this.clusterSprites[a]||(this.clusterSprites[a]=o,this.textureDirty=!0);const h=e.add(o.offset)._sub(n.width/2,n.height/2);let u=h.x,d=h.y;const l=this.getMap(),c=l.getDevicePixelRatio();u*=c,d=(l.height-d)*c;const x=o.data.width*c,p=o.data.height*c;if(this.addPoint(u,d,x,p,r,a),this.layer.options.drawClusterText){t.Canvas.prepareCanvasFont(s,this._textSymbol);const e=s.font+"-"+s.fillStyle,r=this._getClusterText(i),{sprite:o,key:a}=this._getTextSprite(r,e);this.clusterTextSprites[a]||(this.clusterTextSprites[a]=o,this.textTextureDirty=!0),this.addTextPoint(u+x/2,d-p/2,o.data.width*c,o.data.height*c,a)}this.pointCount++}_getTextSprite(e,i){this._textSpriteCache||(this._textSpriteCache={});const r=i+"-"+e;if(!this._textSpriteCache[r]){const i=this.getMap().getDevicePixelRatio(),a=s.measureText(e),n=a.width,h=a.actualBoundingBoxAscent+a.actualBoundingBoxDescent,u=document.createElement("canvas");u.width=n*i,u.height=h*i;const d=u.getContext("2d",{willReadFrequently:!0});d.scale(i,i),t.Canvas.prepareCanvasFont(d,this._textSymbol),d.textBaseline="top",d.fillText(e,0,0);const l=document.getElementById("debug-text-sprite");if(l){l.width=u.width,l.height=u.height;l.getContext("2d").drawImage(u,0,0)}this._textSpriteCache[r]={canvas:u,offset:o,data:d.getImageData(0,0,u.width,u.height)}}return{sprite:this._textSpriteCache[r],key:r}}checkMarksToDraw(){super.checkMarksToDraw(),this._checkToRebuildGeometry()}drawMarkers(t,e){this._checkToRebuildGeometry(),this._animating||i.prototype.draw.call(this,t,e)}_checkToRebuildGeometry(){this._isMarkersDirty&&!this.isInteractingOrAnimating()&&(this.rebuildGeometries(),this._isMarkersDirty=!1)}isInteractingOrAnimating(){return this.getMap().isZooming()||this._animating}flush(t){if(0===this.pointCount)return;this._updateMesh();const e=t&&t.renderTarget&&context.renderTarget.fbo;this._clusterGeometry.setDrawCount(6*this.pointCount);const{width:i,height:r}=this.canvas,s={resolution:[i,r],layerOpacity:this._getLayerOpacity(),dxDy:[0,0]};if(this._renderer.render(this._spriteShader,s,this._scene,e),this.layer.options.drawClusterText){this._textGeometry.setDrawCount(6*this.pointCount);const t=this._textSymbol.textDx||0,i=this._textSymbol.textDy||0;s.dxDy=[t,i],this._renderer.render(this._spriteShader,s,this._textScene,e)}}_updateMesh(){const t=this.textureDirty,e=this._genAtlas();if(this._updateTexCoord(e,t),this.layer.options.drawClusterText){const t=this.textTextureDirty,e=this._genTextAtlas();this._updateTextTexCoord(e,t)}this._updateGeometryData()}addPoint(t,e,i,r,s,o){this._check();const a=i,n=r;this.addVertex(t,e-n,s),this.addVertex(t+a,e-n,s),this.addVertex(t,e,s),this.addVertex(t,e,s),this.addVertex(t+a,e-n,s),this.addVertex(t+a,e,s),this.sprites[this.pointCount]!==o&&(this.sprites[this.pointCount]=o,this.sprites.dirty=!0)}addVertex(t,e,i){const r=this.positionBufferData;r[this.bufferIndex]!==t&&(r[this.bufferIndex]=t,r.dirty=!0),this.bufferIndex++,r[this.bufferIndex]!==e&&(r[this.bufferIndex]=e,r.dirty=!0),this.bufferIndex++;const s=this.opacityBufferData;s[this.opacityIndex]!==i&&(s[this.opacityIndex]=i,s.dirty=!0),this.opacityIndex++}addTextPoint(t,e,i,r,s){this._check();const o=this.getMap().getDevicePixelRatio(),a=(i/=o)/2,n=(r/=o)/2;this.addTextVertex(t-a,e-n),this.addTextVertex(t+a,e-n),this.addTextVertex(t-a,e+n),this.addTextVertex(t-a,e+n),this.addTextVertex(t+a,e-n),this.addTextVertex(t+a,e+n),this.textSprites[this.pointCount]!==s&&(this.textSprites[this.pointCount]=s,this.textSprites.dirty=!0)}addTextVertex(t,e){const i=this.textPositionData;i[this.textIndex]!==t&&(i[this.textIndex]=t,i.dirty=!0),this.textIndex++,i[this.textIndex]!==e&&(i[this.textIndex]=e,i.dirty=!0),this.textIndex++}_check(){if(this.pointCount>=this.maxPointCount-1){this.maxPointCount+=1024;const{positionBufferData:t,texCoordBufferData:e,opacityBufferData:i,textPositionData:r,textTexCoordData:s}=this._initBuffers();for(let i=0;i<this.bufferIndex;i++)t[i]=this.positionBufferData[i],e[i]=this.texCoordBufferData[i],r[i]=this.textPositionData[i],s[i]=this.textTexCoordData[i];for(let t=0;t<this.opacityIndex;t++)i[t]=this.opacityBufferData[t];this.positionBufferData=t,this.texCoordBufferData=e,this.opacityBufferData=i,this.textPositionData=r,this.textTexCoordData=s}}_updateGeometryData(){this.positionBufferData.dirty&&(this._clusterGeometry.updateData("aPosition",this.positionBufferData),this.positionBufferData.dirty=!1),this.opacityBufferData.dirty&&(this._clusterGeometry.updateData("aOpacity",this.opacityBufferData),this._textGeometry.updateData("aOpacity",this.opacityBufferData),this.opacityBufferData.dirty=!1),this.texCoordBufferData.dirty&&(this._clusterGeometry.updateData("aTexCoord",this.texCoordBufferData),this.texCoordBufferData.dirty=!1),this.textPositionData.dirty&&(this._textGeometry.updateData("aPosition",this.textPositionData),this.textPositionData.dirty=!1),this.textTexCoordData.dirty&&(this._textGeometry.updateData("aTexCoord",this.textTexCoordData),this.textTexCoordData.dirty=!1)}_updateTexCoord(t,e){if(!this.sprites.dirty&&!e)return;const{positions:i,image:r}=t,{width:s,height:o}=r;this.texCoordIndex=0;for(let t=0;t<this.pointCount;t++){const e=i[this.sprites[t]],{tl:r,br:a}=e;this._fillTexCoord(r,a,s,o)}this.sprites.dirty=!1}_updateTextTexCoord(t,e){if(!this.textSprites.dirty&&!e)return;const{positions:i,image:r}=t,{width:s,height:o}=r;this.textTexCoordIndex=0;for(let t=0;t<this.pointCount;t++){const e=i[this.textSprites[t]],{tl:r,br:a}=e;this._fillTextTexCoord(r,a,s,o)}this.textSprites.dirty=!1}_initTexture(t,e,i){const r={data:t,width:e,height:i,mag:"linear",min:"linear",premultiplyAlpha:!0};this._clusterTexture?this._clusterTexture.update?this._clusterTexture.update(r):this._clusterTexture(r):this._clusterTexture=this.device.texture(r),this._clusterMesh.setUniform("sourceTexture",this._clusterTexture)}_initTextTexture(t,e,i){const r={data:t,width:e,height:i,mag:"linear",min:"linear",premultiplyAlpha:!0};this._textTexture?this._textTexture.update?this._textTexture.update(r):this._textTexture(r):this._textTexture=this.device.texture(r),this._textMesh.setUniform("sourceTexture",this._textTexture)}_fillTexCoord(t,e,i,r){const s=t[0]/i,o=e[1]/r,a=e[0]/i,n=t[1]/r;this.addVertexTexCoord(s,o),this.addVertexTexCoord(a,o),this.addVertexTexCoord(s,n),this.addVertexTexCoord(s,n),this.addVertexTexCoord(a,o),this.addVertexTexCoord(a,n)}_fillTextTexCoord(t,e,i,r){const s=t[0]/i,o=e[1]/r,a=e[0]/i,n=t[1]/r;this.addTextTexCoord(s,o),this.addTextTexCoord(a,o),this.addTextTexCoord(s,n),this.addTextTexCoord(s,n),this.addTextTexCoord(a,o),this.addTextTexCoord(a,n)}_genAtlas(){if(!this.textureDirty)return this.atlas;const{IconAtlas:t,RGBAImage:e}=r(),i=this.clusterSprites,s={};for(const t in i){const r=i[t],{width:o,height:a,data:n}=r.data,h=new e({width:o,height:a},n);s[t]={data:h,pixelRatio:1}}const o=this.gl&&this.gl instanceof WebGLRenderingContext;this.atlas=new t(s,{nonPowerOfTwo:!o}),this.textureDirty=!1;const{image:a}=this.atlas,{width:n,height:h}=a;return this._initTexture(a.data,n,h),this.atlas}_genTextAtlas(){if(!this.textTextureDirty)return this.textAtlas;const{IconAtlas:t,RGBAImage:e}=r(),i=this.clusterTextSprites,s={};for(const t in i){const r=i[t],{width:o,height:a,data:n}=r.data,h=new e({width:o,height:a},n);s[t]={data:h,pixelRatio:1}}const o=this.gl&&this.gl instanceof WebGLRenderingContext;this.textAtlas=new t(s,{nonPowerOfTwo:!o});const{image:a}=this.textAtlas,{width:n,height:h}=a;this._initTextTexture(a.data,n,h),this.textTextureDirty=!1;const u=document.getElementById("debug-text-atlas");if(u){u.width=n,u.height=h;u.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(a.data.buffer),n,h),0,0)}return this.textAtlas}addVertexTexCoord(t,e){const i=this.texCoordBufferData;i[this.texCoordIndex]!==t&&(i[this.texCoordIndex]=t,i.dirty=!0),this.texCoordIndex++,i[this.texCoordIndex]!==e&&(i[this.texCoordIndex]=e,i.dirty=!0),this.texCoordIndex++}addTextTexCoord(t,e){const i=this.textTexCoordData;i[this.textTexCoordIndex]!==t&&(i[this.textTexCoordIndex]=t,i.dirty=!0),this.textTexCoordIndex++,i[this.textTexCoordIndex]!==e&&(i[this.textTexCoordIndex]=e,i.dirty=!0),this.textTexCoordIndex++}initContext(){return this._initClusterShader(),this._initClusterMeshes(),super.initContext()}onRemove(){return this._spriteShader&&(this._spriteShader.dispose(),delete this._spriteShader),this._clusterMesh&&(this._clusterMesh.dispose(),delete this._clusterMesh),this._clusterGeometry&&(this._clusterGeometry.dispose(),delete this._clusterGeometry),this._textMesh&&(this._textMesh.dispose(),delete this._textMesh),this._textGeometry&&(this._textGeometry.dispose(),delete this._textGeometry),this._clusterTexture&&(this._clusterTexture.destroy(),delete this._clusterTexture),this._textTexture&&(this._textTexture.destroy(),delete this._textTexture),super.onRemove()}_initClusterShader(){const t={viewport:{x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1},depth:{enable:!1},blend:{enable:!0,func:{src:1,dst:"one minus src alpha"}}};this._spriteShader=new e.MeshShader({name:"cluster-sprite",vert:"attribute vec2 aPosition;\nattribute vec2 aTexCoord;\nattribute float aOpacity;\nuniform vec2 resolution;\nuniform vec2 dxDy;\nvarying vec2 vTexCoord;\nvarying float vOpacity;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vOpacity = aOpacity;\n    vec2 position = (aPosition + dxDy) / resolution * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}",frag:"precision mediump float;\nuniform sampler2D sourceTexture;\nuniform float layerOpacity;\nvarying vec2 vTexCoord;\nvarying float vOpacity;\nvoid main() {\n    vec4 color = texture2D(sourceTexture, vTexCoord);\n    gl_FragColor = color * vOpacity * layerOpacity;\n}",wgslVert:"struct VertexInput {\n  @location($i) aPosition: vec2f,\n  @location($i) aTexCoord: vec2f,\n  @location($i) aOpacity: f32,\n};\nstruct VertexOutput {\n  @builtin(position) Position: vec4f,\n  @location($o) vTexCoord: vec2f,\n  @location($o) vOpacity: f32,\n};\nstruct MyAppUniforms {\n  resolution: vec2f,\n  dxDy: vec2f,\n};\n@group(0) @binding($b) var<uniform> uniforms: MyAppUniforms;\n@vertex\nfn main(vertexInput: VertexInput) -> VertexOutput {\n  var output: VertexOutput;\n  output.vTexCoord = vertexInput.aTexCoord;\n  output.vOpacity = vertexInput.aOpacity;\n  let position = (vertexInput.aPosition + uniforms.dxDy) / uniforms.resolution * 2.0 - 1.0;\n  output.Position = vec4f(position, 0.0, 1.0);\n  return output;\n}",wgslFrag:"struct FragmentInput {\n  @location($i) vTexCoord: vec2f,\n  @location($i) vOpacity: f32,\n};\nstruct MyAppUniforms {\n  layerOpacity: f32,\n};\n@group(0) @binding($b) var<uniform> uniforms: MyAppUniforms;\n@group(0) @binding($b) var sourceTexture: texture_2d<f32>;\n@group(0) @binding($b) var sourceTextureSampler: sampler;\n@fragment\nfn main(fragmentInput: FragmentInput) -> @location(0) vec4f {\n  let color = textureSample(sourceTexture, sourceTextureSampler, fragmentInput.vTexCoord);\n  return color * fragmentInput.vOpacity * uniforms.layerOpacity;\n}",extraCommandProps:t})}_initClusterMeshes(){this.maxPointCount=1024,this.pointCount=0,this.clusterSprites={},this.clusterTextSprites={},this.sprites=[],this.textSprites=[],this.spriteCluster=[];const{positionBufferData:t,texCoordBufferData:i,opacityBufferData:r,textPositionData:s,textTexCoordData:o}=this._initBuffers();this.positionBufferData=t,this.texCoordBufferData=i,this.opacityBufferData=r,this.textPositionData=s,this.textTexCoordData=o,this._clusterGeometry=new e.Geometry({aPosition:this.positionBufferData,aTexCoord:this.texCoordBufferData,aOpacity:this.opacityBufferData},null,0,{positionSize:2}),this._clusterGeometry.generateBuffers(this.device),this._clusterMesh=new e.Mesh(this._clusterGeometry),this._scene=new e.Scene([this._clusterMesh]),this._textGeometry=new e.Geometry({aPosition:this.textPositionData,aTexCoord:this.textTexCoordData,aOpacity:this.opacityBufferData},null,0,{positionSize:2}),this._textGeometry.generateBuffers(this.device),this._textMesh=new e.Mesh(this._textGeometry),this._textScene=new e.Scene([this._textMesh]),this._renderer=new e.Renderer(this.device)}_initBuffers(){return{positionBufferData:new Float32Array(2*this.maxPointCount*6),texCoordBufferData:new Float32Array(2*this.maxPointCount*6),opacityBufferData:new Float32Array(1*this.maxPointCount*6),textPositionData:new Float32Array(2*this.maxPointCount*6),textTexCoordData:new Float32Array(2*this.maxPointCount*6)}}_getLayerOpacity(){let e=this.layer&&this.layer.options.opacity;return t.Util.isNil(e)&&(e=1),e}}u.registerRenderer("gl",a),u.registerRenderer("gpu",a)}export{u as ClusterLayer};"undefined"!=typeof console&&console.log("maptalks.markercluster v0.9.3");
//# sourceMappingURL=maptalks.markercluster.es.js.map
