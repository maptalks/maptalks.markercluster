/*!
 * maptalks.markercluster v0.9.0
 * LICENSE : MIT
 * (c) 2016-2025 maptalks.org
 */
import*as t from"maptalks";import{reshader as e}from"@maptalks/gl";import{PointLayerRenderer as r,getVectorPacker as i}from"@maptalks/vt";const s=document.createElement("canvas").getContext("2d"),o=new t.Point(0,0),a=t.DrawToolLayer.markerLayerClazz;let n="canvas";a.getRendererClass("canvas")||(n="gl");const h={"renderer":n,"maxClusterRadius":160,"textSumProperty":null,"symbol":null,"drawClusterText":!0,"textSymbol":null,"animation":!0,"animationDuration":450,"maxClusterZoom":null,"noClusterWithOneMarker":!0,"forceRenderOnZooming":!0};class u extends a{static fromJSON(e){if(!e||"ClusterLayer"!==e.type)return null;const r=new u(e.id,e.options),i=e.geometries,s=[];for(let e=0;e<i.length;e++){const r=t.Geometry.fromJSON(i[e]);r&&s.push(r)}return r.addGeometry(s),r}addMarker(t){return this.addGeometry(t)}addGeometry(e){for(let r=0,i=e.length;r<i;r++)if(!(e[r]instanceof t.Marker))throw new Error("Only a point(Marker) can be added into a ClusterLayer");return super.addGeometry.apply(this,arguments)}onConfig(t){if(super.onConfig(t),t.maxClusterRadius||t.symbol||t.drawClusterText||t.textSymbol||t.maxClusterZoom){const t=this._getRenderer();t&&t.render()}return this}identify(t,e){const r=this.getMap(),i=this.options.maxClusterZoom;return i&&r&&r.getZoom()>i?super.identify(t,e):this._getRenderer()?this._getRenderer().identify(t,e):null}toJSON(){const t=super.toJSON.call(this);return t.type="ClusterLayer",t}getClusters(){const t=this._getRenderer();return t&&t._currentClusters||[]}}u.mergeOptions(h),u.registerJSONType("ClusterLayer");const d={"textFaceName":'"microsoft yahei"',"textSize":16,"textDx":0,"textDy":0},l={"markerType":"ellipse","markerFill":{property:"count",type:"interval",stops:[[0,"rgb(135, 196, 240)"],[9,"#1bbc9b"],[99,"rgb(216, 115, 149)"]]},"markerFillOpacity":.7,"markerLineOpacity":1,"markerLineWidth":3,"markerLineColor":"#fff","markerWidth":{property:"count",type:"interval",stops:[[0,40],[9,60],[99,80]]},"markerHeight":{property:"count",type:"interval",stops:[[0,40],[9,60],[99,80]]}},c=function(e){return class extends e{init(){this._refreshStyle(),this._clusterNeedRedraw=!0}checkResources(){if(!super.checkResources)return[];const e=this.layer.options.symbol||l,r=super.checkResources.apply(this,arguments);if(e!==this._symbolResourceChecked){const i=t.Util.getExternalResources(e,!0);i&&r.push.apply(r,i),this._symbolResourceChecked=e}return r}draw(){this.canvas||this.prepareCanvas();const t=this.getMap().getZoom(),e=this.layer.options.maxClusterZoom;if(e&&t>e)return delete this._currentClusters,this.checkMarksToDraw(),void super.draw.apply(this,arguments);let r;if(this._clusterNeedRedraw&&(this._clearDataCache(),this._computeGrid(),this._clusterNeedRedraw=!1),this._triggerAnimate&&this._startAnimation(t),this._animateDelta)r=this._animateClusters;else{const e=this._clusterCache[t]?this._clusterCache[t].clusters:null;r=this.getClustersToDraw(e),r.zoom=t}this._drawLayer(r)}_startAnimation(e){const r=this._clusterCache[e]?this._clusterCache[e].clusters:null,i=this.getClustersToDraw(r);i.zoom=e,this._animateClusters=i,this._parentClusters=this._currentClusters||i;const s=this.layer;if(s.options.animation&&this._triggerAnimate){let e=[0,1];"in"===this._inout&&(e=[1,0]),this._animateDelta=e[0],this._player=t.animation.Animation.animate({"d":e},{"speed":s.options.animationDuration,"easing":"inAndOut"},t=>{this._animateDelta=t.styles.d,"finished"===t.state.playState&&(delete this._animateDelta,delete this._inout,delete this._animateClusters,delete this._parentClusters),this.setToRedraw()}).play(),this.setToRedraw()}this._triggerAnimate=!1}checkMarksToDraw(){const t=this._markersToDraw!==this.layer._geoList;this._markersToDraw=this.layer._geoList,this._markersToDraw.dirty=t}getClustersToDraw(e){const r=this._markersToDraw||[];this._markersToDraw=[];const i=this.getMap(),s=t.StringUtil.getFont(this._textSymbol),o=t.StringUtil.stringLength("9",s).toPoint(),a=i.getContainerExtent(),n=[];let h,u,d,l,c,x=0,p=!1;for(const s in e){if(this._currentGrid=e[s],1===e[s].count&&this.layer.options.noClusterWithOneMarker){const t=e[s].children[0];t._cluster=e[s],p||r[x++]===t||(p=!0),this._markersToDraw.push(t);continue}if(d=this._getSprite().sprite,l=d.canvas.width,c=d.canvas.height,h=i._prjToContainerPoint(e[s].center),u=new t.PointExtent(h.sub(l,c),h.add(l,c)),a.intersects(u)){if(!e[s].textSize){const r=this._getClusterText(e[s]);e[s].textSize=new t.Point(o.x*r.length,o.y)._multi(.5)}n.push(e[s])}}return r.length!==this._markersToDraw.length&&(p=!0),this._markersToDraw.dirty=p,n}drawOnInteracting(...t){this._currentClusters&&this.drawClusters(this._currentClusters,1),super.drawOnInteracting(...t)}getCurrentNeedRenderGeos(){return this._markersToDraw?this._markersToDraw:[]}_getCurrentNeedRenderGeos(){return this.getCurrentNeedRenderGeos()}forEachGeo(t,e){this._markersToDraw&&this._markersToDraw.forEach(r=>{e?t.call(e,r):t(r)})}onGeometryShow(){this._clusterNeedRedraw=!0,super.onGeometryShow.apply(this,arguments)}onGeometryHide(){this._clusterNeedRedraw=!0,super.onGeometryHide.apply(this,arguments)}onGeometryAdd(){this._clusterNeedRedraw=!0,super.onGeometryAdd.apply(this,arguments)}onGeometryRemove(){this._clusterNeedRedraw=!0,super.onGeometryRemove.apply(this,arguments)}onGeometryPositionChange(){this._clusterNeedRedraw=!0,super.onGeometryPositionChange.apply(this,arguments)}onRemove(){this._clearDataCache()}identify(t,e){const r=this.getMap(),i=this.layer.options.maxClusterZoom;if(i&&r.getZoom()>i)return super.identify(t,e);if(this._currentClusters){const e=r.coordinateToContainerPoint(t),i=this._currentGrid;for(let t=0;t<this._currentClusters.length;t++){const i=this._currentClusters[t],s=r._prjToContainerPoint(i.center);this._currentGrid=i;const o=this._getSprite().sprite.canvas.width;if(e.distanceTo(s)<=o)return{"center":r.getProjection().unproject(i.center.copy()),"children":i.children.slice(0)}}this._currentGrid=i}if(this._markersToDraw&&this._markersToDraw[0]){const i=r.coordinateToContainerPoint(t);return this.layer._hitGeos(this._markersToDraw,i,e)}return null}onSymbolChanged(){this._refreshStyle(),this._computeGrid(),this._stopAnim(),this.setToRedraw()}_refreshStyle(){const e=this.layer.options.symbol||l,r=this.layer.options.textSymbol||d,i=()=>[this.getMap().getZoom(),this._currentGrid];this._symbol=t.MapboxUtil.loadFunctionTypes(e,i),this._textSymbol=t.MapboxUtil.loadFunctionTypes(r,i)}_drawLayer(t){this._currentClusters=t,this._animateDelta>=0?"in"===this._inout?this.drawClustersFrame(t,this._parentClusters,this._animateDelta):this.drawClustersFrame(this._parentClusters,t,this._animateDelta):this.drawClusters(t,1),this.drawMarkers(),this.completeRender()}drawMarkers(){super.drawGeos()}drawClustersFrame(t,e,r){this.prepareCanvas();const i=this.getMap(),s={};if(t&&t.forEach(t=>{const e=i._prjToContainerPoint(t.center);s[t.key]||(s[t.key]=1,this.drawCluster(e,t,1-r))}),0===r||!e)return;const o=t.zoom,a=i._getResolution(o)*this.layer.options.maxClusterRadius,n=this._markerExtent.getMin();e.forEach(t=>{let e=i._prjToContainerPoint(t.center);const s=t.center,h=Math.floor((s.x-n.x)/a)+"_"+Math.floor((s.y-n.y)/a),u=this._clusterCache[o]?this._clusterCache[o].clusterMap[h]:null;if(u){const t=i._prjToContainerPoint(u.center);e=t.add(e.sub(t)._multi(r))}this.drawCluster(e,t,r>.5?1:r)})}drawClusters(t,e){if(!t)return;this.prepareCanvas();const r=this.getMap();t.forEach(t=>{const i=r._prjToContainerPoint(t.center);this.drawCluster(i,t,e>.5?1:e)})}drawCluster(e,r,i){this._currentGrid=r;const s=this.context,o=this._getSprite().sprite,a=s.globalAlpha;if(a*i!==0){if(s.globalAlpha=a*i,o){const r=e.add(o.offset)._sub(o.canvas.width/2,o.canvas.height/2);t.Canvas.image(s,o.canvas,r.x,r.y)}if(this.layer.options.drawClusterText&&r.textSize){t.Canvas.prepareCanvasFont(s,this._textSymbol),s.textBaseline="middle";const i=this._textSymbol.textDx||0,o=this._textSymbol.textDy||0,a=this._getClusterText(r);t.Canvas.fillText(s,a,e.sub(r.textSize.x,0)._add(i,o))}s.globalAlpha=a}}_getClusterText(t){return(this.layer.options.textSumProperty?t.textSumProperty:t.count)+""}_getSprite(){this._spriteCache||(this._spriteCache={});const e=function(t){const e=[];for(const r in t)"_"!==r[0]&&e.push(t[r]);return e.join("|")}(this._symbol);return this._spriteCache[e]||(this._spriteCache[e]=new t.Marker([0,0],{"symbol":this._symbol})._getSprite(this.resources,this.getMap().CanvasClass)),{sprite:this._spriteCache[e],key:e}}_initGridSystem(){const t=[];let e,r;this.layer.forEach(i=>{i.isVisible()&&(r=i._getPrjCoordinates(),e=e?e._combine(i._getPrjExtent()):i._getPrjExtent(),t.push({x:r.x,y:r.y,id:i._getInternalId(),geometry:i}))}),this._markerExtent=e,this._markerPoints=t}_computeGrid(){const t=this.getMap(),e=t.getZoom();this._markerExtent||this._initGridSystem(),this._clusterCache||(this._clusterCache={});const r=t._getResolution(t.getMinZoom())>t._getResolution(t.getMaxZoom())?e-1:e+1;this._clusterCache[r]&&this._clusterCache[r].length===this.layer.getCount()&&(this._clusterCache[e]=this._clusterCache[r]),this._clusterCache[e]||(this._clusterCache[e]=this._computeZoomGrid(e))}_computeZoomGrid(e){if(!this._markerExtent)return null;const r=this.getMap(),i=r._getResolution(e)*this.layer.options.maxClusterRadius,s=r._getResolution(e-1)?r._getResolution(e-1)*this.layer.options.maxClusterRadius:null;let o=this._clusterCache[e-1];!o&&e-1>=r.getMinZoom()&&(this._clusterCache[e-1]=o=this._computeZoomGrid(e-1));const a=this._markerPoints,n=this.layer.options.textSumProperty,h={},u=this._markerExtent.getMin();let d,l,c,x,p,y;for(let e=0,r=a.length;e<r;e++){const r=a[e].geometry;let _=0;n&&r.getProperties()&&r.getProperties()[n]&&(_=r.getProperties()[n]),d=Math.floor((a[e].x-u.x)/i),l=Math.floor((a[e].y-u.y)/i),c=d+"_"+l,h[c]?(h[c].sum._add(new t.Coordinate(a[e].x,a[e].y)),h[c].count++,h[c].center=h[c].sum.multi(1/h[c].count),h[c].children.push(r),h[c].textSumProperty+=_):(h[c]={"sum":new t.Coordinate(a[e].x,a[e].y),"center":new t.Coordinate(a[e].x,a[e].y),"count":1,"textSumProperty":_,"children":[r],"key":c+""},s&&o&&(x=Math.floor((a[e].x-u.x)/s),p=Math.floor((a[e].y-u.y)/s),y=x+"_"+p,h[c].parent=o.clusterMap[y]))}return this._mergeClusters(h,i/2)}_mergeClusters(t,e){const r={};for(const e in t)r[e]=t[e];const i={},s={};let o,a;for(const r in t){if(o=t[r],s[o.key])continue;const n=o.key.split("_"),h=+n[0],u=+n[1];for(let r=-1;r<=1;r++)for(let n=-1;n<=1;n++){if(0===r&&0===n)continue;a=t[h+r+"_"+(u+n)],a&&this._distanceTo(o.center,a.center)<=e&&(i[o.key]||(i[o.key]=[]),i[o.key].push(a),s[a.key]=1)}}for(const e in i){const s=t[e];if(!s)continue;const o=i[e];for(let e=0;e<o.length;e++)t[o[e].key]&&(s.sum._add(o[e].sum),s.count+=o[e].count,s.textSumProperty+=o[e].textSumProperty,s.children=s.children.concat(o[e].children),r[o[e].key]=s,delete t[o[e].key]);s.center=s.sum.multi(1/s.count)}return{"clusters":t,"clusterMap":r}}_distanceTo(t,e){const r=t.x-e.x,i=t.y-e.y;return Math.sqrt(r*r+i*i)}_stopAnim(){this._player&&"finished"!==this._player.playState&&this._player.finish()}onZoomStart(t){this._stopAnim(),super.onZoomStart(t)}onZoomEnd(t){!this.layer.isEmpty()&&this.layer.isVisible()?(this._inout=t.from>t.to?"in":"out",this._triggerAnimate=!0,this._computeGrid(),super.onZoomEnd.apply(this,arguments)):super.onZoomEnd.apply(this,arguments)}_clearDataCache(){this._stopAnim(),delete this._markerExtent,delete this._markerPoints,delete this._clusterCache,delete this._zoomInClusters}}};class x extends(c(t.renderer.VectorLayerCanvasRenderer)){constructor(...t){super(...t),this.init()}}if(u.registerRenderer("canvas",x),void 0!==r){class a extends(c(r)){constructor(...t){super(...t),this.init()}drawOnInteracting(t,e,i){this._currentClusters&&this.drawClusters(this._currentClusters,1),this.drawMarkers(),r.prototype.draw.call(this,e,i)}drawClusters(...t){this._clearToDraw(),super.drawClusters(...t),this.flush()}drawClustersFrame(...t){this._clearToDraw(),super.drawClustersFrame(...t),this.flush()}_clearToDraw(){this.pointCount=0,this.bufferIndex=0,this.opacityIndex=0,this.textIndex=0}drawCluster(e,r,i){this._currentGrid=r;const{sprite:o,key:a}=this._getSprite(),n=o.canvas;o.data||(o.data=n.getContext("2d",{willReadFrequently:!0}).getImageData(0,0,n.width,n.height)),this.clusterSprites[a]||(this.clusterSprites[a]=o,this.textureDirty=!0);const h=e.add(o.offset)._sub(n.width/2,n.height/2);let u=h.x,d=h.y;const l=this.getMap(),c=l.getDevicePixelRatio();u*=c,d=(l.height-d)*c;const x=o.data.width*c,p=o.data.height*c;if(this.addPoint(u,d,x,p,i,a),this.layer.options.drawClusterText){t.Canvas.prepareCanvasFont(s,this._textSymbol);const e=s.font+"-"+s.fillStyle,i=this._getClusterText(r),{sprite:o,key:a}=this._getTextSprite(i,e);this.clusterTextSprites[a]||(this.clusterTextSprites[a]=o,this.textTextureDirty=!0),this.addTextPoint(u+x/2,d-p/2,o.data.width*c,o.data.height*c,a)}this.pointCount++}_getTextSprite(e,r){this._textSpriteCache||(this._textSpriteCache={});const i=r+"-"+e;if(!this._textSpriteCache[i]){const r=this.getMap().getDevicePixelRatio(),a=s.measureText(e),n=a.width,h=a.actualBoundingBoxAscent+a.actualBoundingBoxDescent,u=document.createElement("canvas");u.width=n*r,u.height=h*r;const d=u.getContext("2d",{willReadFrequently:!0});d.scale(r,r),t.Canvas.prepareCanvasFont(d,this._textSymbol),d.textBaseline="top",d.fillText(e,0,0);const l=document.getElementById("debug-text-sprite");if(l){l.width=u.width,l.height=u.height;l.getContext("2d").drawImage(u,0,0)}this._textSpriteCache[i]={canvas:u,offset:o,data:d.getImageData(0,0,u.width,u.height)}}return{sprite:this._textSpriteCache[i],key:i}}checkMarksToDraw(){super.checkMarksToDraw(),this.drawMarkers()}drawMarkers(){this._markersToDraw.dirty&&(this.rebuildGeometries(),this._markersToDraw.dirty=!1)}flush(t){if(0===this.pointCount)return;this._updateMesh();const e=t&&t.renderTarget&&context.renderTarget.fbo;this._clusterGeometry.setDrawCount(6*this.pointCount);const{width:r,height:i}=this.canvas,s={resolution:[r,i],layerOpacity:this._getLayerOpacity(),dxDy:[0,0]};if(this._renderer.render(this._spriteShader,s,this._scene,e),this.layer.options.drawClusterText){this._textGeometry.setDrawCount(6*this.pointCount);const t=this._textSymbol.textDx||0,r=this._textSymbol.textDy||0;s.dxDy=[t,r],this._renderer.render(this._spriteShader,s,this._textScene,e)}}_updateMesh(){const t=this.textureDirty,e=this._genAtlas();if(this._updateTexCoord(e,t),this.layer.options.drawClusterText){const t=this.textTextureDirty,e=this._genTextAtlas();this._updateTextTexCoord(e,t)}this._updateGeometryData()}addPoint(t,e,r,i,s,o){this._check();const a=r,n=i;this.addVertex(t,e-n,s),this.addVertex(t+a,e-n,s),this.addVertex(t,e,s),this.addVertex(t,e,s),this.addVertex(t+a,e-n,s),this.addVertex(t+a,e,s),this.sprites[this.pointCount]!==o&&(this.sprites[this.pointCount]=o,this.sprites.dirty=!0)}addVertex(t,e,r){const i=this.positionBufferData;i[this.bufferIndex]!==t&&(i[this.bufferIndex]=t,i.dirty=!0),this.bufferIndex++,i[this.bufferIndex]!==e&&(i[this.bufferIndex]=e,i.dirty=!0),this.bufferIndex++;const s=this.opacityBufferData;s[this.opacityIndex]!==r&&(s[this.opacityIndex]=r,s.dirty=!0),this.opacityIndex++}addTextPoint(t,e,r,i,s){this._check();const o=this.getMap().getDevicePixelRatio(),a=(r/=o)/2,n=(i/=o)/2;this.addTextVertex(t-a,e-n),this.addTextVertex(t+a,e-n),this.addTextVertex(t-a,e+n),this.addTextVertex(t-a,e+n),this.addTextVertex(t+a,e-n),this.addTextVertex(t+a,e+n),this.textSprites[this.pointCount]!==s&&(this.textSprites[this.pointCount]=s,this.textSprites.dirty=!0)}addTextVertex(t,e){const r=this.textPositionData;r[this.textIndex]!==t&&(r[this.textIndex]=t,r.dirty=!0),this.textIndex++,r[this.textIndex]!==e&&(r[this.textIndex]=e,r.dirty=!0),this.textIndex++}_check(){if(this.pointCount>=this.maxPointCount-1){this.maxPointCount+=1024;const{positionBufferData:t,texCoordBufferData:e,opacityBufferData:r,textPositionData:i,textTexCoordData:s}=this._initBuffers();for(let r=0;r<this.bufferIndex;r++)t[r]=this.positionBufferData[r],e[r]=this.texCoordBufferData[r],i[r]=this.textPositionData[r],s[r]=this.textTexCoordData[r];for(let t=0;t<this.opacityIndex;t++)r[t]=this.opacityBufferData[t];this.positionBufferData=t,this.texCoordBufferData=e,this.opacityBufferData=r,this.textPositionData=i,this.textTexCoordData=s}}_updateGeometryData(){this.positionBufferData.dirty&&(this._clusterGeometry.updateData("aPosition",this.positionBufferData),this.positionBufferData.dirty=!1),this.opacityBufferData.dirty&&(this._clusterGeometry.updateData("aOpacity",this.opacityBufferData),this._textGeometry.updateData("aOpacity",this.opacityBufferData),this.opacityBufferData.dirty=!1),this.texCoordBufferData.dirty&&(this._clusterGeometry.updateData("aTexCoord",this.texCoordBufferData),this.texCoordBufferData.dirty=!1),this.textPositionData.dirty&&(this._textGeometry.updateData("aPosition",this.textPositionData),this.textPositionData.dirty=!1),this.textTexCoordData.dirty&&(this._textGeometry.updateData("aTexCoord",this.textTexCoordData),this.textTexCoordData.dirty=!1)}_updateTexCoord(t,e){if(!this.sprites.dirty&&!e)return;const{positions:r,image:i}=t,{width:s,height:o}=i;this.texCoordIndex=0;for(let t=0;t<this.pointCount;t++){const e=r[this.sprites[t]],{tl:i,br:a}=e;this._fillTexCoord(i,a,s,o)}this.sprites.dirty=!1}_updateTextTexCoord(t,e){if(!this.textSprites.dirty&&!e)return;const{positions:r,image:i}=t,{width:s,height:o}=i;this.textTexCoordIndex=0;for(let t=0;t<this.pointCount;t++){const e=r[this.textSprites[t]],{tl:i,br:a}=e;this._fillTextTexCoord(i,a,s,o)}this.textSprites.dirty=!1}_initTexture(t,e,r){const i={data:t,width:e,height:r,mag:"linear",min:"linear",premultiplyAlpha:!0};this._clusterTexture?this._clusterTexture.update?this._clusterTexture.update(i):this._clusterTexture(i):this._clusterTexture=this.device.texture(i),this._clusterMesh.setUniform("sourceTexture",this._clusterTexture)}_initTextTexture(t,e,r){const i={data:t,width:e,height:r,mag:"linear",min:"linear",premultiplyAlpha:!0};this._textTexture?this._textTexture.update?this._textTexture.update(i):this._textTexture(i):this._textTexture=this.device.texture(i),this._textMesh.setUniform("sourceTexture",this._textTexture)}_fillTexCoord(t,e,r,i){const s=t[0]/r,o=e[1]/i,a=e[0]/r,n=t[1]/i;this.addVertexTexCoord(s,o),this.addVertexTexCoord(a,o),this.addVertexTexCoord(s,n),this.addVertexTexCoord(s,n),this.addVertexTexCoord(a,o),this.addVertexTexCoord(a,n)}_fillTextTexCoord(t,e,r,i){const s=t[0]/r,o=e[1]/i,a=e[0]/r,n=t[1]/i;this.addTextTexCoord(s,o),this.addTextTexCoord(a,o),this.addTextTexCoord(s,n),this.addTextTexCoord(s,n),this.addTextTexCoord(a,o),this.addTextTexCoord(a,n)}_genAtlas(){if(!this.textureDirty)return this.atlas;const{IconAtlas:t,RGBAImage:e}=i(),r=this.clusterSprites,s={};for(const t in r){const i=r[t],{width:o,height:a,data:n}=i.data,h=new e({width:o,height:a},n);s[t]={data:h,pixelRatio:1}}const o=this.gl&&this.gl instanceof WebGLRenderingContext;this.atlas=new t(s,{nonPowerOfTwo:!o}),this.textureDirty=!1;const{image:a}=this.atlas,{width:n,height:h}=a;return this._initTexture(a.data,n,h),this.atlas}_genTextAtlas(){if(!this.textTextureDirty)return this.textAtlas;const{IconAtlas:t,RGBAImage:e}=i(),r=this.clusterTextSprites,s={};for(const t in r){const i=r[t],{width:o,height:a,data:n}=i.data,h=new e({width:o,height:a},n);s[t]={data:h,pixelRatio:1}}const o=this.gl&&this.gl instanceof WebGLRenderingContext;this.textAtlas=new t(s,{nonPowerOfTwo:!o});const{image:a}=this.textAtlas,{width:n,height:h}=a;this._initTextTexture(a.data,n,h),this.textTextureDirty=!1;const u=document.getElementById("debug-text-atlas");if(u){u.width=n,u.height=h;u.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(a.data.buffer),n,h),0,0)}return this.textAtlas}addVertexTexCoord(t,e){const r=this.texCoordBufferData;r[this.texCoordIndex]!==t&&(r[this.texCoordIndex]=t,r.dirty=!0),this.texCoordIndex++,r[this.texCoordIndex]!==e&&(r[this.texCoordIndex]=e,r.dirty=!0),this.texCoordIndex++}addTextTexCoord(t,e){const r=this.textTexCoordData;r[this.textTexCoordIndex]!==t&&(r[this.textTexCoordIndex]=t,r.dirty=!0),this.textTexCoordIndex++,r[this.textTexCoordIndex]!==e&&(r[this.textTexCoordIndex]=e,r.dirty=!0),this.textTexCoordIndex++}initContext(){return this._initClusterShader(),this._initClusterMeshes(),super.initContext()}onRemove(){return this._spriteShader&&(this._spriteShader.dispose(),delete this._spriteShader),this._clusterMesh&&(this._clusterMesh.dispose(),delete this._clusterMesh),this._clusterGeometry&&(this._clusterGeometry.dispose(),delete this._clusterGeometry),this._textMesh&&(this._textMesh.dispose(),delete this._textMesh),this._textGeometry&&(this._textGeometry.dispose(),delete this._textGeometry),this._clusterTexture&&(this._clusterTexture.destroy(),delete this._clusterTexture),this._textTexture&&(this._textTexture.destroy(),delete this._textTexture),super.onRemove()}_initClusterShader(){const t={viewport:{x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1},depth:{enable:!1},blend:{enable:!0,func:{src:1,dst:"one minus src alpha"}}};this._spriteShader=new e.MeshShader({name:"cluster-sprite",vert:"attribute vec2 aPosition;\nattribute vec2 aTexCoord;\nattribute float aOpacity;\nuniform vec2 resolution;\nuniform vec2 dxDy;\nvarying vec2 vTexCoord;\nvarying float vOpacity;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vOpacity = aOpacity;\n    vec2 position = (aPosition + dxDy) / resolution * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}",frag:"precision mediump float;\nuniform sampler2D sourceTexture;\nuniform float layerOpacity;\nvarying vec2 vTexCoord;\nvarying float vOpacity;\nvoid main() {\n    vec4 color = texture2D(sourceTexture, vTexCoord);\n    gl_FragColor = color * vOpacity * layerOpacity;\n}",wgslVert:"struct VertexInput {\n  @location($i) aPosition: vec2f,\n  @location($i) aTexCoord: vec2f,\n  @location($i) aOpacity: f32,\n};\nstruct VertexOutput {\n  @builtin(position) Position: vec4f,\n  @location($o) vTexCoord: vec2f,\n  @location($o) vOpacity: f32,\n};\nstruct MyAppUniforms {\n  resolution: vec2f,\n  dxDy: vec2f,\n};\n@group(0) @binding($b) var<uniform> uniforms: MyAppUniforms;\n@vertex\nfn main(vertexInput: VertexInput) -> VertexOutput {\n  var output: VertexOutput;\n  output.vTexCoord = vertexInput.aTexCoord;\n  output.vOpacity = vertexInput.aOpacity;\n  let position = (vertexInput.aPosition + uniforms.dxDy) / uniforms.resolution * 2.0 - 1.0;\n  output.Position = vec4f(position, 0.0, 1.0);\n  return output;\n}",wgslFrag:"struct FragmentInput {\n  @location($i) vTexCoord: vec2f,\n  @location($i) vOpacity: f32,\n};\nstruct MyAppUniforms {\n  layerOpacity: f32,\n};\n@group(0) @binding($b) var<uniform> uniforms: MyAppUniforms;\n@group(0) @binding($b) var sourceTexture: texture_2d<f32>;\n@group(0) @binding($b) var sourceTextureSampler: sampler;\n@fragment\nfn main(fragmentInput: FragmentInput) -> @location(0) vec4f {\n  let color = textureSample(sourceTexture, sourceTextureSampler, fragmentInput.vTexCoord);\n  return color * fragmentInput.vOpacity * uniforms.layerOpacity;\n}",extraCommandProps:t})}_initClusterMeshes(){this.maxPointCount=1024,this.pointCount=0,this.clusterSprites={},this.clusterTextSprites={},this.sprites=[],this.textSprites=[],this.spriteCluster=[];const{positionBufferData:t,texCoordBufferData:r,opacityBufferData:i,textPositionData:s,textTexCoordData:o}=this._initBuffers();this.positionBufferData=t,this.texCoordBufferData=r,this.opacityBufferData=i,this.textPositionData=s,this.textTexCoordData=o,this._clusterGeometry=new e.Geometry({aPosition:this.positionBufferData,aTexCoord:this.texCoordBufferData,aOpacity:this.opacityBufferData},null,0,{positionSize:2}),this._clusterGeometry.generateBuffers(this.device),this._clusterMesh=new e.Mesh(this._clusterGeometry),this._scene=new e.Scene([this._clusterMesh]),this._textGeometry=new e.Geometry({aPosition:this.textPositionData,aTexCoord:this.textTexCoordData,aOpacity:this.opacityBufferData},null,0,{positionSize:2}),this._textGeometry.generateBuffers(this.device),this._textMesh=new e.Mesh(this._textGeometry),this._textScene=new e.Scene([this._textMesh]),this._renderer=new e.Renderer(this.device)}_initBuffers(){return{positionBufferData:new Float32Array(2*this.maxPointCount*6),texCoordBufferData:new Float32Array(2*this.maxPointCount*6),opacityBufferData:new Float32Array(1*this.maxPointCount*6),textPositionData:new Float32Array(2*this.maxPointCount*6),textTexCoordData:new Float32Array(2*this.maxPointCount*6)}}_getLayerOpacity(){let e=this.layer&&this.layer.options.opacity;return t.Util.isNil(e)&&(e=1),e}}u.registerRenderer("gl",a),u.registerRenderer("gpu",a)}export{u as ClusterLayer};"undefined"!=typeof console&&console.log("maptalks.markercluster v0.9.0");
//# sourceMappingURL=maptalks.markercluster.es.js.map
