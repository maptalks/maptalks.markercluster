{"version":3,"file":"maptalks.markercluster.js","sources":["../index.js"],"sourcesContent":["import * as maptalks from 'maptalks';\nimport { reshader } from '@maptalks/gl';\nimport { getVectorPacker, PointLayerRenderer } from '@maptalks/vt';\nimport vert from './glsl/sprite.vert';\nimport frag from './glsl/sprite.frag';\nimport wgslVert from './wgsl/sprite_vert.wgsl';\nimport wgslFrag from './wgsl/sprite_frag.wgsl';\n\nconst FONT_CANVAS = document.createElement('canvas');\nconst fontCtx = FONT_CANVAS.getContext('2d');\nconst ZERO_POINT = new maptalks.Point(0, 0);\n\nconst MarkerLayerClazz = maptalks.DrawToolLayer.markerLayerClazz;\nlet renderer = 'canvas';\nconst RendererClazz = MarkerLayerClazz.getRendererClass('canvas');\nif (!RendererClazz) {\n    renderer = 'gl';\n}\n\nconst options = {\n    'renderer': renderer,\n    'maxClusterRadius' : 160,\n    'textSumProperty' : null,\n    'symbol' : null,\n    'drawClusterText' : true,\n    'textSymbol' : null,\n    'animation' : true,\n    'animationDuration' : 450,\n    'maxClusterZoom' : null,\n    'noClusterWithOneMarker':true,\n    'forceRenderOnZooming' : true\n};\n\nexport class ClusterLayer extends MarkerLayerClazz {\n    /**\n     * Reproduce a ClusterLayer from layer's profile JSON.\n     * @param  {Object} json - layer's profile JSON\n     * @return {maptalks.ClusterLayer}\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(json) {\n        if (!json || json['type'] !== 'ClusterLayer') { return null; }\n        const layer = new ClusterLayer(json['id'], json['options']);\n        const geoJSONs = json['geometries'];\n        const geometries = [];\n        for (let i = 0; i < geoJSONs.length; i++) {\n            const geo = maptalks.Geometry.fromJSON(geoJSONs[i]);\n            if (geo) {\n                geometries.push(geo);\n            }\n        }\n        layer.addGeometry(geometries);\n        return layer;\n    }\n\n    addMarker(markers) {\n        return this.addGeometry(markers);\n    }\n\n    addGeometry(markers) {\n        for (let i = 0, len = markers.length; i < len; i++) {\n            if (!(markers[i] instanceof maptalks.Marker)) {\n                throw new Error('Only a point(Marker) can be added into a ClusterLayer');\n            }\n        }\n        return super.addGeometry.apply(this, arguments);\n    }\n\n    onConfig(conf) {\n        super.onConfig(conf);\n        if (conf['maxClusterRadius'] ||\n            conf['symbol'] ||\n            conf['drawClusterText'] ||\n            conf['textSymbol'] ||\n            conf['maxClusterZoom']) {\n            const renderer = this._getRenderer();\n            if (renderer) {\n                renderer.render();\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Identify the clusters on the given coordinate\n     * @param  {maptalks.Coordinate} coordinate   - coordinate to identify\n     * @return {Object|Geometry[]}  result: cluster { center : [cluster's center], children : [geometries in the cluster] } or markers\n     */\n    identify(coordinate, options) {\n        const map = this.getMap(),\n            maxZoom = this.options['maxClusterZoom'];\n        if (maxZoom && map && map.getZoom() > maxZoom) {\n            return super.identify(coordinate, options);\n        }\n        if (this._getRenderer()) {\n            return this._getRenderer().identify(coordinate, options);\n        }\n        return null;\n    }\n\n    /**\n     * Export the ClusterLayer's JSON.\n     * @return {Object} layer's JSON\n     */\n    toJSON() {\n        const json = super.toJSON.call(this);\n        json['type'] = 'ClusterLayer';\n        return json;\n    }\n    /**\n     * Get the ClusterLayer's current clusters\n     * @return {Object} layer's clusters\n     **/\n    getClusters() {\n        const renderer = this._getRenderer();\n        if (renderer) {\n            return renderer._currentClusters || [];\n        }\n        return [];\n    }\n}\n\n// merge to define ClusterLayer's default options.\nClusterLayer.mergeOptions(options);\n\n// register ClusterLayer's JSON type for JSON deserialization.\nClusterLayer.registerJSONType('ClusterLayer');\n\nconst defaultTextSymbol = {\n    'textFaceName'      : '\"microsoft yahei\"',\n    'textSize'          : 16,\n    'textDx'            : 0,\n    'textDy'            : 0\n};\n\nconst defaultSymbol = {\n    'markerType' : 'ellipse',\n    'markerFill' : { property:'count', type:'interval', stops: [[0, 'rgb(135, 196, 240)'], [9, '#1bbc9b'], [99, 'rgb(216, 115, 149)']] },\n    'markerFillOpacity' : 0.7,\n    'markerLineOpacity' : 1,\n    'markerLineWidth' : 3,\n    'markerLineColor' : '#fff',\n    'markerWidth' : { property:'count', type:'interval', stops: [[0, 40], [9, 60], [99, 80]] },\n    'markerHeight' : { property:'count', type:'interval', stops: [[0, 40], [9, 60], [99, 80]] }\n};\n\nconst ClusterLayerRenderable = function(Base) {\n    const renderable = class extends Base {\n        init() {\n            this._refreshStyle();\n            this._clusterNeedRedraw = true;\n        }\n\n        checkResources() {\n            if (!super.checkResources) {\n                return [];\n            }\n            const symbol = this.layer.options['symbol'] || defaultSymbol;\n            const resources = super.checkResources.apply(this, arguments);\n            if (symbol !== this._symbolResourceChecked) {\n                const res = maptalks.Util.getExternalResources(symbol, true);\n                if (res) {\n                    resources.push.apply(resources, res);\n                }\n                this._symbolResourceChecked = symbol;\n            }\n            return resources;\n        }\n\n        draw() {\n            if (!this.canvas) {\n                this.prepareCanvas();\n            }\n            const map = this.getMap();\n            const zoom = map.getZoom();\n            const maxClusterZoom = this.layer.options['maxClusterZoom'];\n            if (maxClusterZoom &&  zoom > maxClusterZoom) {\n                delete this._currentClusters;\n                this.checkMarksToDraw();\n                super.draw.apply(this, arguments);\n                return;\n            }\n            if (this._clusterNeedRedraw) {\n                this._clearDataCache();\n                this._computeGrid();\n                this._clusterNeedRedraw = false;\n            }\n            let clusters;\n            if (this._triggerAnimate) {\n                this._startAnimation(zoom);\n            }\n            if (this._animateDelta) {\n                clusters = this._animateClusters;\n            } else {\n                const zoomClusters = this._clusterCache[zoom] ? this._clusterCache[zoom]['clusters'] : null;\n                clusters = this.getClustersToDraw(zoomClusters);\n                clusters.zoom = zoom;\n            }\n            this._drawLayer(clusters);\n        }\n\n        _startAnimation(zoom) {\n            const zoomClusters = this._clusterCache[zoom] ? this._clusterCache[zoom]['clusters'] : null;\n            const clusters = this.getClustersToDraw(zoomClusters);\n            clusters.zoom = zoom;\n\n            this._animateClusters = clusters;\n            this._parentClusters = this._currentClusters || clusters;\n            const layer = this.layer;\n            if (layer.options['animation'] && this._triggerAnimate) {\n                let dr = [0, 1];\n                if (this._inout === 'in') {\n                    dr = [1, 0];\n                }\n                this._animateDelta = dr[0];\n                this._player = maptalks.animation.Animation.animate(\n                    { 'd' : dr },\n                    { 'speed' : layer.options['animationDuration'], 'easing' : 'inAndOut' },\n                    frame => {\n                        this._animateDelta = frame.styles.d;\n                        if (frame.state.playState === 'finished') {\n                            delete this._animateDelta;\n                            delete this._inout;\n                            delete this._animateClusters;\n                            delete this._parentClusters\n                        }\n                        this.setToRedraw();\n                    }\n                )\n                .play();\n                this.setToRedraw();\n            }\n            this._triggerAnimate = false;\n        }\n\n        checkMarksToDraw() {\n            const dirty = this._markersToDraw !== this.layer._geoList;\n            this._markersToDraw = this.layer._geoList;\n            this._markersToDraw.dirty = dirty;\n        }\n\n        getClustersToDraw(zoomClusters) {\n            const oldMarkersToDraw = this._markersToDraw || [];\n            this._markersToDraw = [];\n            const map = this.getMap();\n            const font = maptalks.StringUtil.getFont(this._textSymbol),\n                digitLen = maptalks.StringUtil.stringLength('9', font).toPoint();\n            const extent = map.getContainerExtent(),\n                clusters = [];\n            let pt, pExt, sprite, width, height, markerIndex = 0, isMarkerDirty = false;\n            for (const p in zoomClusters) {\n                this._currentGrid = zoomClusters[p];\n                if (zoomClusters[p]['count'] === 1 && this.layer.options['noClusterWithOneMarker']) {\n                    const marker = zoomClusters[p]['children'][0];\n                    marker._cluster = zoomClusters[p];\n                    if (!isMarkerDirty && oldMarkersToDraw[markerIndex++] !== marker) {\n                        isMarkerDirty = true;\n                    }\n                    this._markersToDraw.push(marker);\n                    continue;\n                }\n                sprite = this._getSprite().sprite;\n                width = sprite.canvas.width;\n                height = sprite.canvas.height;\n                pt = map._prjToContainerPoint(zoomClusters[p]['center']);\n                pExt = new maptalks.PointExtent(pt.sub(width, height), pt.add(width, height));\n                if (!extent.intersects(pExt)) {\n                    continue;\n                }\n                if (!zoomClusters[p]['textSize']) {\n                    const text = this._getClusterText(zoomClusters[p]);\n                    zoomClusters[p]['textSize'] = new maptalks.Point(digitLen.x * text.length, digitLen.y)._multi(1 / 2);\n                }\n                clusters.push(zoomClusters[p]);\n            }\n            if (oldMarkersToDraw.length !== this._markersToDraw.length) {\n                isMarkerDirty = true;\n            }\n            this._markersToDraw.dirty = isMarkerDirty;\n            return clusters;\n        }\n\n        drawOnInteracting(...args) {\n            if (this._currentClusters) {\n                this.drawClusters(this._currentClusters, 1);\n            }\n            super.drawOnInteracting(...args);\n        }\n\n        getCurrentNeedRenderGeos() {\n            if (this._markersToDraw) {\n                return this._markersToDraw;\n            }\n            return [];\n        }\n\n        _getCurrentNeedRenderGeos() {\n            return this.getCurrentNeedRenderGeos();\n        }\n\n        forEachGeo(fn, context) {\n            if (this._markersToDraw) {\n                this._markersToDraw.forEach((g) => {\n                    if (context) {\n                        fn.call(context, g);\n                    } else {\n                        fn(g);\n                    }\n                });\n            }\n        }\n\n        onGeometryShow() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryShow.apply(this, arguments);\n        }\n\n        onGeometryHide() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryHide.apply(this, arguments);\n        }\n\n        onGeometryAdd() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryAdd.apply(this, arguments);\n        }\n\n        onGeometryRemove() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryRemove.apply(this, arguments);\n        }\n\n        onGeometryPositionChange() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryPositionChange.apply(this, arguments);\n        }\n\n        onRemove() {\n            this._clearDataCache();\n        }\n\n        identify(coordinate, options) {\n            const map = this.getMap(),\n                maxZoom = this.layer.options['maxClusterZoom'];\n            if (maxZoom && map.getZoom() > maxZoom) {\n                return super.identify(coordinate, options);\n            }\n            if (this._currentClusters) {\n                const point = map.coordinateToContainerPoint(coordinate);\n                const old = this._currentGrid;\n                for (let i = 0; i < this._currentClusters.length; i++) {\n                    const c = this._currentClusters[i];\n                    const pt = map._prjToContainerPoint(c['center']);\n                    this._currentGrid = c;\n                    const markerWidth = this._getSprite().sprite.canvas.width;\n\n                    if (point.distanceTo(pt) <= markerWidth) {\n                        return {\n                            'center'   : map.getProjection().unproject(c.center.copy()),\n                            'children' : c.children.slice(0)\n                        };\n                    }\n                }\n                this._currentGrid = old;\n            }\n\n            // if no clusters is hit, identify markers\n            if (this._markersToDraw && this._markersToDraw[0]) {\n                const point = map.coordinateToContainerPoint(coordinate);\n                return this.layer._hitGeos(this._markersToDraw, point, options);\n            }\n            return null;\n        }\n\n        onSymbolChanged() {\n            this._refreshStyle();\n            this._computeGrid();\n            this._stopAnim();\n            this.setToRedraw();\n        }\n\n        _refreshStyle() {\n            const symbol = this.layer.options['symbol'] || defaultSymbol;\n            const textSymbol = this.layer.options['textSymbol'] || defaultTextSymbol;\n            const argFn =  () => [this.getMap().getZoom(), this._currentGrid];\n            this._symbol = maptalks.MapboxUtil.loadFunctionTypes(symbol, argFn);\n            this._textSymbol = maptalks.MapboxUtil.loadFunctionTypes(textSymbol, argFn);\n        }\n\n        _drawLayer(clusters) {\n            this._currentClusters = clusters;\n            if (this._animateDelta >= 0) {\n                if (this._inout === 'in') {\n                    this.drawClustersFrame(clusters, this._parentClusters, this._animateDelta);\n                } else {\n                    this.drawClustersFrame(this._parentClusters, clusters, this._animateDelta);\n                }\n            } else {\n                this.drawClusters(clusters, 1);\n            }\n            this.drawMarkers();\n            this.completeRender();\n        }\n\n        drawMarkers() {\n            super.drawGeos();\n        }\n\n        drawClustersFrame(parentClusters, toClusters, ratio) {\n            this.prepareCanvas();\n            const map = this.getMap(),\n                drawn = {};\n            if (parentClusters) {\n                parentClusters.forEach(c => {\n                    const p = map._prjToContainerPoint(c['center']);\n                    if (!drawn[c.key]) {\n                        drawn[c.key] = 1;\n                        this.drawCluster(p, c, 1 - ratio);\n                    }\n                });\n            }\n            if (ratio === 0 || !toClusters) {\n                return;\n            }\n            const z = parentClusters.zoom,\n                r = map._getResolution(z) * this.layer.options['maxClusterRadius'],\n                min = this._markerExtent.getMin();\n            toClusters.forEach(c => {\n                let pt = map._prjToContainerPoint(c['center']);\n                const center = c.center;\n                const pgx = Math.floor((center.x - min.x) / r),\n                    pgy = Math.floor((center.y - min.y) / r);\n                const pkey = pgx + '_' + pgy;\n                const parent = this._clusterCache[z] ? this._clusterCache[z]['clusterMap'][pkey] : null;\n                if (parent) {\n                    const pp = map._prjToContainerPoint(parent['center']);\n                    pt = pp.add(pt.sub(pp)._multi(ratio));\n                }\n                this.drawCluster(pt, c, ratio > 0.5 ? 1 : ratio);\n            });\n        }\n\n        drawClusters(clusters, ratio) {\n            if (!clusters) {\n                return;\n            }\n            this.prepareCanvas();\n            const map = this.getMap();\n            clusters.forEach(c => {\n                const pt = map._prjToContainerPoint(c['center']);\n                this.drawCluster(pt, c, ratio > 0.5 ? 1 : ratio);\n            });\n\n        }\n\n        drawCluster(pt, cluster, op) {\n            this._currentGrid = cluster;\n            const ctx = this.context;\n            const sprite = this._getSprite().sprite;\n            const opacity = ctx.globalAlpha;\n            if (opacity * op === 0) {\n                return;\n            }\n            ctx.globalAlpha = opacity * op;\n            if (sprite) {\n                const pos = pt.add(sprite.offset)._sub(sprite.canvas.width / 2, sprite.canvas.height / 2);\n                maptalks.Canvas.image(ctx, sprite.canvas, pos.x, pos.y);\n            }\n\n            if (this.layer.options['drawClusterText'] && cluster['textSize']) {\n                maptalks.Canvas.prepareCanvasFont(ctx, this._textSymbol);\n                ctx.textBaseline = 'middle';\n                const dx = this._textSymbol['textDx'] || 0;\n                const dy = this._textSymbol['textDy'] || 0;\n                const text = this._getClusterText(cluster);\n                maptalks.Canvas.fillText(ctx, text, pt.sub(cluster['textSize'].x, 0)._add(dx, dy));\n            }\n            ctx.globalAlpha = opacity;\n        }\n\n        _getClusterText(cluster) {\n            const text = this.layer.options['textSumProperty'] ? cluster['textSumProperty'] : cluster['count'];\n            return text + '';\n        }\n\n        _getSprite() {\n            if (!this._spriteCache) {\n                this._spriteCache = {};\n            }\n            const key = getSymbolStamp(this._symbol);\n            if (!this._spriteCache[key]) {\n                this._spriteCache[key] = new maptalks.Marker([0, 0], { 'symbol' : this._symbol })._getSprite(this.resources, this.getMap().CanvasClass);\n            }\n            return {\n                sprite: this._spriteCache[key],\n                key\n            };\n        }\n\n        _initGridSystem() {\n            const points = [];\n            let extent, c;\n            this.layer.forEach(g => {\n                if (!g.isVisible()) {\n                    return;\n                }\n                c = g._getPrjCoordinates();\n                if (!extent) {\n                    extent = g._getPrjExtent();\n                } else {\n                    extent = extent._combine(g._getPrjExtent());\n                }\n                points.push({\n                    x : c.x,\n                    y : c.y,\n                    id : g._getInternalId(),\n                    geometry : g\n                });\n            });\n            this._markerExtent = extent;\n            this._markerPoints = points;\n        }\n\n        _computeGrid() {\n            const map = this.getMap(),\n                zoom = map.getZoom();\n            if (!this._markerExtent) {\n                this._initGridSystem();\n            }\n            if (!this._clusterCache) {\n                this._clusterCache = {};\n            }\n            const pre = map._getResolution(map.getMinZoom()) > map._getResolution(map.getMaxZoom()) ? zoom - 1 : zoom + 1;\n            if (this._clusterCache[pre] && this._clusterCache[pre].length === this.layer.getCount()) {\n                this._clusterCache[zoom] = this._clusterCache[pre];\n            }\n            if (!this._clusterCache[zoom]) {\n                this._clusterCache[zoom] = this._computeZoomGrid(zoom);\n            }\n        }\n\n        _computeZoomGrid(zoom) {\n            if (!this._markerExtent) {\n                return null;\n            }\n            const map = this.getMap(),\n                r = map._getResolution(zoom) * this.layer.options['maxClusterRadius'],\n                preT = map._getResolution(zoom - 1) ? map._getResolution(zoom - 1) * this.layer.options['maxClusterRadius'] : null;\n            let preCache = this._clusterCache[zoom - 1];\n            if (!preCache && zoom - 1 >= map.getMinZoom()) {\n                this._clusterCache[zoom - 1] = preCache = this._computeZoomGrid(zoom - 1);\n            }\n            // 1. format extent of markers to grids with raidus of r\n            // 2. find point's grid in the grids\n            // 3. sum up the point into the grid's collection\n            const points = this._markerPoints;\n            const sumProperty = this.layer.options['textSumProperty'];\n            const grids = {},\n                min = this._markerExtent.getMin();\n            let gx, gy, key,\n                pgx, pgy, pkey;\n            for (let i = 0, len = points.length; i < len; i++) {\n                const geo = points[i].geometry;\n                let sumProp = 0;\n\n                if (sumProperty && geo.getProperties() && geo.getProperties()[sumProperty]) {\n                    sumProp = geo.getProperties()[sumProperty];\n                }\n\n                gx = Math.floor((points[i].x - min.x) / r);\n                gy = Math.floor((points[i].y - min.y) / r);\n                key = gx + '_' + gy;\n                if (!grids[key]) {\n                    grids[key] = {\n                        'sum' : new maptalks.Coordinate(points[i].x, points[i].y),\n                        'center' : new maptalks.Coordinate(points[i].x, points[i].y),\n                        'count' : 1,\n                        'textSumProperty' : sumProp,\n                        'children' :[geo],\n                        'key' : key + ''\n                    };\n                    if (preT && preCache) {\n                        pgx = Math.floor((points[i].x - min.x) / preT);\n                        pgy = Math.floor((points[i].y - min.y) / preT);\n                        pkey = pgx + '_' + pgy;\n                        grids[key]['parent'] = preCache['clusterMap'][pkey];\n                    }\n                } else {\n\n                    grids[key]['sum']._add(new maptalks.Coordinate(points[i].x, points[i].y));\n                    grids[key]['count']++;\n                    grids[key]['center'] = grids[key]['sum'].multi(1 / grids[key]['count']);\n                    grids[key]['children'].push(geo);\n                    grids[key]['textSumProperty'] += sumProp;\n                }\n            }\n            return this._mergeClusters(grids, r / 2);\n        }\n\n        _mergeClusters(grids, r) {\n            const clusterMap = {};\n            for (const p in grids) {\n                clusterMap[p] = grids[p];\n            }\n\n            // merge adjacent clusters\n            const merging = {};\n\n            const visited = {};\n            // find clusters need to merge\n            let c1, c2;\n            for (const p in grids) {\n                c1 = grids[p];\n                if (visited[c1.key]) {\n                    continue;\n                }\n                const gxgy = c1.key.split('_');\n                const gx = +(gxgy[0]),\n                    gy = +(gxgy[1]);\n                //traverse adjacent grids\n                for (let ii = -1; ii <= 1; ii++) {\n                    for (let iii = -1; iii <= 1; iii++) {\n                        if (ii === 0 && iii === 0) {\n                            continue;\n                        }\n                        const key2 = (gx + ii) + '_' + (gy + iii);\n                        c2 = grids[key2];\n                        if (c2 && this._distanceTo(c1['center'], c2['center']) <= r) {\n                            if (!merging[c1.key]) {\n                                merging[c1.key] = [];\n                            }\n                            merging[c1.key].push(c2);\n                            visited[c2.key] = 1;\n                        }\n                    }\n                }\n            }\n\n            //merge clusters\n            for (const m in merging) {\n                const grid = grids[m];\n                if (!grid) {\n                    continue;\n                }\n                const toMerge = merging[m];\n                for (let i = 0; i < toMerge.length; i++) {\n                    if (grids[toMerge[i].key]) {\n                        grid['sum']._add(toMerge[i].sum);\n                        grid['count'] += toMerge[i].count;\n                        grid['textSumProperty'] += toMerge[i].textSumProperty;\n                        grid['children'] = grid['children'].concat(toMerge[i].children);\n                        clusterMap[toMerge[i].key] = grid;\n                        delete grids[toMerge[i].key];\n                    }\n                }\n                grid['center'] = grid['sum'].multi(1 / grid['count']);\n            }\n\n            return {\n                'clusters' : grids,\n                'clusterMap' : clusterMap\n            };\n        }\n\n        _distanceTo(c1, c2) {\n            const x = c1.x - c2.x,\n                y = c1.y - c2.y;\n            return Math.sqrt(x * x + y * y);\n        }\n\n        _stopAnim() {\n            if (this._player && this._player.playState !== 'finished') {\n                this._player.finish();\n            }\n        }\n\n        onZoomStart(param) {\n            this._stopAnim();\n            super.onZoomStart(param);\n        }\n\n        onZoomEnd(param) {\n            if (this.layer.isEmpty() || !this.layer.isVisible()) {\n                super.onZoomEnd.apply(this, arguments);\n                return;\n            }\n            this._inout = param['from'] > param['to'] ? 'in' : 'out';\n            this._triggerAnimate = true;\n            this._computeGrid();\n            super.onZoomEnd.apply(this, arguments);\n        }\n\n        _clearDataCache() {\n            this._stopAnim();\n            delete this._markerExtent;\n            delete this._markerPoints;\n            delete this._clusterCache;\n            delete this._zoomInClusters;\n        }\n    };\n    return renderable;\n}\n\nclass ClusterLayerRenderer extends ClusterLayerRenderable(maptalks.renderer.VectorLayerCanvasRenderer) {\n\n    constructor(...args) {\n        super(...args);\n        this.init();\n    }\n}\n\nClusterLayer.registerRenderer('canvas', ClusterLayerRenderer);\n\nif (typeof PointLayerRenderer !== 'undefined') {\n    class ClusterGLRenderer extends ClusterLayerRenderable(PointLayerRenderer) {\n        constructor(...args) {\n            super(...args);\n            this.init();\n        }\n\n        drawOnInteracting(event, timestamp, parentContext) {\n            if (this._currentClusters) {\n                this.drawClusters(this._currentClusters, 1);\n            }\n            this.drawMarkers();\n            PointLayerRenderer.prototype.draw.call(this, timestamp, parentContext);\n        }\n\n        drawClusters(...args) {\n            this._clearToDraw();\n            super.drawClusters(...args);\n            this.flush();\n        }\n\n        drawClustersFrame(...args) {\n            this._clearToDraw();\n            super.drawClustersFrame(...args);\n            this.flush();\n        }\n\n        _clearToDraw() {\n            this.pointCount = 0;\n            this.bufferIndex = 0;\n            this.opacityIndex = 0;\n            this.textIndex = 0;\n        }\n\n        drawCluster(pt, cluster, opacity) {\n            this._currentGrid = cluster;\n            const { sprite, key } = this._getSprite();\n            const canvas = sprite.canvas;\n            if (!sprite.data) {\n                sprite.data = canvas.getContext('2d', { willReadFrequently: true }).getImageData(0, 0, canvas.width, canvas.height);\n            }\n            if (!this.clusterSprites[key]) {\n                this.clusterSprites[key] = sprite;\n                this.textureDirty = true;\n            }\n            const pos = pt.add(sprite.offset)._sub(canvas.width / 2, canvas.height / 2);\n            let x = pos.x;\n            let y = pos.y;\n            const map = this.getMap();\n            const pixelRatio = map.getDevicePixelRatio();\n            const height = map.height;\n            x = x * pixelRatio;\n            y = (height - y) * pixelRatio;\n            const spriteW = sprite.data.width * pixelRatio;\n            const spriteH = sprite.data.height * pixelRatio;\n\n            this.addPoint(x, y, spriteW, spriteH, opacity, key);\n\n            if (this.layer.options['drawClusterText']) {\n                maptalks.Canvas.prepareCanvasFont(fontCtx, this._textSymbol);\n                const fontKey = fontCtx.font + '-' + fontCtx.fillStyle;\n                const text = this._getClusterText(cluster);\n                const { sprite, key } = this._getTextSprite(text, fontKey);\n                if (!this.clusterTextSprites[key]) {\n                    this.clusterTextSprites[key] = sprite;\n                    this.textTextureDirty = true;\n                }\n                this.addTextPoint(x + spriteW / 2, y - spriteH / 2, sprite.data.width * pixelRatio, sprite.data.height * pixelRatio, key);\n            }\n            this.pointCount++;\n\n        }\n\n        _getTextSprite(text, fontKey) {\n            if (!this._textSpriteCache) {\n                this._textSpriteCache = {};\n            }\n            const key = fontKey + '-' + text;\n            if (!this._textSpriteCache[key]) {\n                const dpr = this.getMap().getDevicePixelRatio();\n                const metrics = fontCtx.measureText(text);\n                const textWidth = metrics.width;\n                const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n                const canvas = document.createElement('canvas');\n                canvas.width = textWidth * dpr;\n                canvas.height = textHeight * dpr;\n                const ctx = canvas.getContext('2d', { willReadFrequently: true });\n                ctx.scale(dpr, dpr);\n                maptalks.Canvas.prepareCanvasFont(ctx, this._textSymbol);\n                ctx.textBaseline = 'top';\n                ctx.fillText(text, 0, 0);\n                const debugCanvas = document.getElementById('debug-text-sprite');\n                if (debugCanvas) {\n                    debugCanvas.width = canvas.width;\n                    debugCanvas.height = canvas.height;\n                    const ctx = debugCanvas.getContext('2d');\n                    ctx.drawImage(canvas, 0, 0);\n                }\n\n                this._textSpriteCache[key] = {\n                    canvas,\n                    offset: ZERO_POINT,\n                    data: ctx.getImageData(0, 0, canvas.width, canvas.height)\n                };\n            }\n            return {\n                sprite: this._textSpriteCache[key],\n                key\n            };\n        }\n\n        checkMarksToDraw() {\n            super.checkMarksToDraw();\n            this.drawMarkers();\n        }\n\n        drawMarkers() {\n            if (this._markersToDraw.dirty) {\n                this.rebuildGeometries();\n                this._markersToDraw.dirty = false;\n            }\n        }\n\n        flush(parentContext) {\n            if (this.pointCount === 0) {\n                return;\n            }\n            this._updateMesh();\n            const fbo = parentContext && parentContext.renderTarget && context.renderTarget.fbo;\n            this._clusterGeometry.setDrawCount(this.pointCount * 6);\n            const { width, height } = this.canvas;\n            const layerOpacity = this._getLayerOpacity();\n            const uniforms = {\n                resolution: [width, height],\n                layerOpacity,\n                dxDy: [0, 0]\n            };\n            this._renderer.render(this._spriteShader, uniforms, this._scene, fbo);\n\n            if (this.layer.options['drawClusterText']) {\n                this._textGeometry.setDrawCount(this.pointCount * 6);\n                const dx = this._textSymbol['textDx'] || 0;\n                const dy = this._textSymbol['textDy'] || 0;\n                uniforms.dxDy = [dx, dy];\n                this._renderer.render(this._spriteShader, uniforms, this._textScene, fbo);\n            }\n        }\n\n        _updateMesh() {\n\n            const isAtlasDirty = this.textureDirty;\n            const atlas = this._genAtlas();\n            this._updateTexCoord(atlas, isAtlasDirty);\n            // text\n            if (this.layer.options['drawClusterText']) {\n                const isAtlasDirty = this.textTextureDirty;\n                const textAtlas = this._genTextAtlas();\n                this._updateTextTexCoord(textAtlas, isAtlasDirty);\n            }\n\n            this._updateGeometryData();\n        }\n\n        addPoint(x, y, width, height, opacity, key) {\n            this._check();\n            const w = width;\n            const h = height;\n\n            this.addVertex(x, y - h, opacity);\n            this.addVertex(x + w, y - h, opacity);\n            this.addVertex(x, y, opacity);\n            this.addVertex(x, y, opacity);\n            this.addVertex(x + w, y - h, opacity);\n            this.addVertex(x + w, y, opacity);\n            if (this.sprites[this.pointCount] !== key) {\n                this.sprites[this.pointCount] = key;\n                this.sprites.dirty = true;\n            }\n        }\n\n        addVertex(x, y, opacity) {\n            const positionBufferData = this.positionBufferData;\n            if (positionBufferData[this.bufferIndex] !== x) {\n                positionBufferData[this.bufferIndex] = x;\n                positionBufferData.dirty = true;\n            }\n            this.bufferIndex++;\n            if (positionBufferData[this.bufferIndex] !== y) {\n                positionBufferData[this.bufferIndex] = y;\n                positionBufferData.dirty = true;\n            }\n            this.bufferIndex++;\n\n            const opacityBufferData = this.opacityBufferData;\n            // opacity *= 255;\n            // U8[0] = opacity;\n            if (opacityBufferData[this.opacityIndex] !== opacity) {\n                opacityBufferData[this.opacityIndex] = opacity;\n                opacityBufferData.dirty = true;\n            }\n            this.opacityIndex++;\n        }\n\n        addTextPoint(x, y, width, height, key) {\n            this._check();\n            const dpr = this.getMap().getDevicePixelRatio();\n            width /= dpr;\n            height /= dpr;\n            const w = width / 2;\n            const h = height / 2;\n\n            this.addTextVertex(x - w, y - h);\n            this.addTextVertex(x + w, y - h);\n            this.addTextVertex(x - w, y + h);\n            this.addTextVertex(x - w, y + h);\n            this.addTextVertex(x + w, y - h);\n            this.addTextVertex(x + w, y + h);\n\n            if (this.textSprites[this.pointCount] !== key) {\n                this.textSprites[this.pointCount] = key;\n                this.textSprites.dirty = true;\n            }\n        }\n\n        addTextVertex(x, y) {\n            const textPositionData = this.textPositionData;\n            if (textPositionData[this.textIndex] !== x) {\n                textPositionData[this.textIndex] = x;\n                textPositionData.dirty = true;\n            }\n            this.textIndex++;\n            if (textPositionData[this.textIndex] !== y) {\n                textPositionData[this.textIndex] = y;\n                textPositionData.dirty = true;\n            }\n            this.textIndex++;\n        }\n\n        _check() {\n            if (this.pointCount >= this.maxPointCount - 1) {\n                this.maxPointCount += 1024;\n                const { positionBufferData, texCoordBufferData, opacityBufferData, textPositionData, textTexCoordData } = this._initBuffers();\n                for (let i = 0; i < this.bufferIndex; i++) {\n                    positionBufferData[i] = this.positionBufferData[i];\n                    texCoordBufferData[i] = this.texCoordBufferData[i];\n                    textPositionData[i] = this.textPositionData[i];\n                    textTexCoordData[i] = this.textTexCoordData[i];\n                }\n                for (let i = 0; i < this.opacityIndex; i++) {\n                    opacityBufferData[i] = this.opacityBufferData[i];\n                }\n                this.positionBufferData = positionBufferData;\n                this.texCoordBufferData = texCoordBufferData;\n                this.opacityBufferData = opacityBufferData;\n                this.textPositionData = textPositionData;\n                this.textTexCoordData = textTexCoordData;\n            }\n        }\n\n        _updateGeometryData() {\n            // icon\n            if (this.positionBufferData.dirty) {\n                this._clusterGeometry.updateData('aPosition', this.positionBufferData);\n                // console.log(this.positionBufferData);\n                this.positionBufferData.dirty = false;\n            }\n            if (this.opacityBufferData.dirty) {\n                this._clusterGeometry.updateData('aOpacity', this.opacityBufferData);\n                this._textGeometry.updateData('aOpacity', this.opacityBufferData);\n                this.opacityBufferData.dirty = false;\n            }\n            if (this.texCoordBufferData.dirty) {\n                this._clusterGeometry.updateData('aTexCoord', this.texCoordBufferData);\n                this.texCoordBufferData.dirty = false;\n            }\n\n            // text\n            if (this.textPositionData.dirty) {\n                this._textGeometry.updateData('aPosition', this.textPositionData);\n                this.textPositionData.dirty = false;\n            }\n            if (this.textTexCoordData.dirty) {\n                this._textGeometry.updateData('aTexCoord', this.textTexCoordData);\n                this.textTexCoordData.dirty = false;\n            }\n        }\n\n        _updateTexCoord(atlas, isAtlasDirty) {\n            if (!this.sprites.dirty && !isAtlasDirty) {\n                return;\n            }\n            const { positions, image } = atlas;\n            const { width, height } = image;\n            this.texCoordIndex = 0;\n            for (let i = 0; i < this.pointCount; i++) {\n                const bin = positions[this.sprites[i]];\n                const { tl, br } = bin;\n                this._fillTexCoord(tl, br, width, height);\n            }\n            this.sprites.dirty = false;\n        }\n\n        _updateTextTexCoord(atlas, isAtlasDirty) {\n            if (!this.textSprites.dirty && !isAtlasDirty) {\n                return;\n            }\n            const { positions, image } = atlas;\n            const { width, height } = image;\n            this.textTexCoordIndex = 0;\n            for (let i = 0; i < this.pointCount; i++) {\n                const bin = positions[this.textSprites[i]];\n                const { tl, br } = bin;\n                this._fillTextTexCoord(tl, br, width, height);\n            }\n            this.textSprites.dirty = false;\n        }\n\n        _initTexture(data, width, height) {\n            const config = {\n                data,\n                width,\n                height,\n                mag: 'linear',\n                min: 'linear',\n                premultiplyAlpha: true\n            };\n            if (this._clusterTexture) {\n                if (this._clusterTexture.update) {\n                    this._clusterTexture.update(config);\n                } else {\n                    this._clusterTexture(config);\n                }\n            } else {\n                this._clusterTexture = this.device.texture(config);\n            }\n            this._clusterMesh.setUniform('sourceTexture', this._clusterTexture);\n        }\n\n        _initTextTexture(data, width, height) {\n            const config = {\n                data,\n                width,\n                height,\n                mag: 'linear',\n                min: 'linear',\n                premultiplyAlpha: true\n            };\n            if (this._textTexture) {\n                if (this._textTexture.update) {\n                    this._textTexture.update(config);\n                } else {\n                    this._textTexture(config);\n                }\n            } else {\n                this._textTexture = this.device.texture(config);\n            }\n            this._textMesh.setUniform('sourceTexture', this._textTexture);\n        }\n\n        _fillTexCoord(tl, br, texWidth, texHeight) {\n            const u1 = tl[0] / texWidth;\n            const v1 = br[1] / texHeight;\n            const u2 = br[0] / texWidth;\n            const v2 = tl[1] / texHeight;\n\n            this.addVertexTexCoord(u1, v1);\n            this.addVertexTexCoord(u2, v1);\n            this.addVertexTexCoord(u1, v2);\n            this.addVertexTexCoord(u1, v2);\n            this.addVertexTexCoord(u2, v1);\n            this.addVertexTexCoord(u2, v2);\n        }\n\n        _fillTextTexCoord(tl, br, texWidth, texHeight) {\n            const u1 = tl[0] / texWidth;\n            const v1 = br[1] / texHeight;\n            const u2 = br[0] / texWidth;\n            const v2 = tl[1] / texHeight;\n\n            this.addTextTexCoord(u1, v1);\n            this.addTextTexCoord(u2, v1);\n            this.addTextTexCoord(u1, v2);\n            this.addTextTexCoord(u1, v2);\n            this.addTextTexCoord(u2, v1);\n            this.addTextTexCoord(u2, v2);\n        }\n\n        _genAtlas() {\n            if (!this.textureDirty) {\n                return this.atlas;\n            }\n            const { IconAtlas, RGBAImage } = getVectorPacker();\n            const icons = this.clusterSprites;\n            const iconMap = {};\n            for (const url in icons) {\n                const icon = icons[url];\n                const { width, height, data } = icon.data;\n                const image = new RGBAImage({ width, height }, data);\n                iconMap[url] = { data: image, pixelRatio: 1 };\n            }\n            const isWebGL1 = this.gl && (this.gl instanceof WebGLRenderingContext);\n            this.atlas = new IconAtlas(iconMap, { nonPowerOfTwo: !isWebGL1 });\n            this.textureDirty = false;\n            const { image } = this.atlas;\n            const { width, height } = image;\n            this._initTexture(image.data, width, height);\n            return this.atlas;\n        }\n\n        _genTextAtlas() {\n            if (!this.textTextureDirty) {\n                return this.textAtlas;\n            }\n            const { IconAtlas, RGBAImage } = getVectorPacker();\n            const texts = this.clusterTextSprites;\n            const textMap = {};\n            for (const key in texts) {\n                const textSprite = texts[key];\n                const { width, height, data } = textSprite.data;\n                const image = new RGBAImage({ width, height }, data);\n                textMap[key] = { data: image, pixelRatio: 1 };\n            }\n            const isWebGL1 = this.gl && (this.gl instanceof WebGLRenderingContext);\n            this.textAtlas = new IconAtlas(textMap, { nonPowerOfTwo: !isWebGL1 });\n            const { image } = this.textAtlas;\n            const { width, height } = image;\n            this._initTextTexture(image.data, width, height);\n            this.textTextureDirty = false;\n\n            const debugCanvas = document.getElementById('debug-text-atlas');\n            if (debugCanvas) {\n                debugCanvas.width = width;\n                debugCanvas.height = height;\n                const ctx = debugCanvas.getContext('2d');\n                ctx.putImageData(new ImageData(new Uint8ClampedArray(image.data.buffer), width, height), 0, 0);\n            }\n\n            return this.textAtlas;\n        }\n\n        addVertexTexCoord(u, v) {\n            const texCoordBufferData = this.texCoordBufferData;\n            if (texCoordBufferData[this.texCoordIndex] !== u) {\n                texCoordBufferData[this.texCoordIndex] = u;\n                texCoordBufferData.dirty = true;\n            }\n            this.texCoordIndex++;\n            if (texCoordBufferData[this.texCoordIndex] !== v) {\n                texCoordBufferData[this.texCoordIndex] = v;\n                texCoordBufferData.dirty = true;\n            }\n            this.texCoordIndex++;\n        }\n\n        addTextTexCoord(u, v) {\n            const textTexCoordData = this.textTexCoordData;\n            if (textTexCoordData[this.textTexCoordIndex] !== u) {\n                textTexCoordData[this.textTexCoordIndex] = u;\n                textTexCoordData.dirty = true;\n            }\n            this.textTexCoordIndex++;\n            if (textTexCoordData[this.textTexCoordIndex] !== v) {\n                textTexCoordData[this.textTexCoordIndex] = v;\n                textTexCoordData.dirty = true;\n            }\n            this.textTexCoordIndex++;\n        }\n\n        initContext() {\n            // this.\n            this._initClusterShader();\n            this._initClusterMeshes();\n            return super.initContext();\n        }\n\n        onRemove() {\n            if (this._spriteShader) {\n                this._spriteShader.dispose();\n                delete this._spriteShader;\n            }\n            if (this._clusterMesh) {\n                this._clusterMesh.dispose();\n                delete this._clusterMesh;\n            }\n            if (this._clusterGeometry) {\n                this._clusterGeometry.dispose();\n                delete this._clusterGeometry;\n            }\n            if (this._textMesh) {\n                this._textMesh.dispose();\n                delete this._textMesh;\n            }\n            if (this._textGeometry) {\n                this._textGeometry.dispose();\n                delete this._textGeometry;\n            }\n            if (this._clusterTexture) {\n                this._clusterTexture.destroy();\n                delete this._clusterTexture;\n            }\n            if (this._textTexture) {\n                this._textTexture.destroy();\n                delete this._textTexture;\n            }\n            return super.onRemove();\n        }\n\n        _initClusterShader() {\n            const viewport = {\n                x : 0,\n                y : 0,\n                width : () => {\n                    return this.canvas ? this.canvas.width : 1;\n                },\n                height : () => {\n                    return this.canvas ? this.canvas.height : 1;\n                }\n            };\n\n            const extraCommandProps = {\n                viewport,\n                depth: {\n                    enable: false\n                },\n                blend: {\n                    enable: true,\n                    func: {\n                        src: 1,\n                        dst: 'one minus src alpha'\n                    }\n                }\n            };\n\n            this._spriteShader = new reshader.MeshShader({\n                name: 'cluster-sprite',\n                vert,\n                frag,\n                wgslVert,\n                wgslFrag,\n                extraCommandProps\n            });\n        }\n\n        _initClusterMeshes() {\n            this.maxPointCount = 1024;\n            this.pointCount = 0;\n            this.clusterSprites = {};\n            this.clusterTextSprites = {};\n            this.sprites = [];\n            this.textSprites = [];\n            this.spriteCluster = [];\n\n            const {\n                positionBufferData, texCoordBufferData, opacityBufferData,\n                textPositionData, textTexCoordData\n            } = this._initBuffers();\n            this.positionBufferData = positionBufferData;\n            this.texCoordBufferData = texCoordBufferData;\n            this.opacityBufferData = opacityBufferData;\n            this.textPositionData = textPositionData;\n            this.textTexCoordData = textTexCoordData;\n\n            this._clusterGeometry = new reshader.Geometry({\n                aPosition: this.positionBufferData,\n                aTexCoord: this.texCoordBufferData,\n                aOpacity: this.opacityBufferData\n            }, null, 0, {\n                positionSize: 2\n            });\n            this._clusterGeometry.generateBuffers(this.device);\n            this._clusterMesh = new reshader.Mesh(this._clusterGeometry);\n            this._scene = new reshader.Scene([this._clusterMesh]);\n\n            this._textGeometry = new reshader.Geometry({\n                aPosition: this.textPositionData,\n                aTexCoord: this.textTexCoordData,\n                aOpacity: this.opacityBufferData\n            }, null, 0, {\n                positionSize: 2\n            });\n            this._textGeometry.generateBuffers(this.device);\n            this._textMesh = new reshader.Mesh(this._textGeometry);\n            this._textScene = new reshader.Scene([this._textMesh]);\n\n            this._renderer = new reshader.Renderer(this.device);\n        }\n\n        _initBuffers() {\n            const vertexSize = 2;\n            const texCoordSize = 2;\n            const opacitySize = 1;\n\n            const positionBufferData = new Float32Array(this.maxPointCount * vertexSize * 6);\n            const texCoordBufferData = new Float32Array(this.maxPointCount * texCoordSize * 6);\n            const opacityBufferData = new Float32Array(this.maxPointCount * opacitySize * 6);\n            // opacityBufferData.fill(255);\n\n            const textPositionData = new Float32Array(this.maxPointCount * vertexSize * 6);\n            const textTexCoordData = new Float32Array(this.maxPointCount * texCoordSize * 6);\n\n            return { positionBufferData, texCoordBufferData, opacityBufferData, textPositionData, textTexCoordData };\n        }\n\n        _getLayerOpacity() {\n            let layerOpacity = this.layer && this.layer.options['opacity'];\n            if (maptalks.Util.isNil(layerOpacity)) {\n                layerOpacity = 1;\n            }\n            return layerOpacity;\n        }\n    }\n    ClusterLayer.registerRenderer('gl', ClusterGLRenderer);\n    ClusterLayer.registerRenderer('gpu', ClusterGLRenderer);\n}\n\nfunction getSymbolStamp(symbol) {\n    const values = [];\n    for (const p in symbol) {\n        if (p[0] === '_') {\n            continue;\n        }\n        values.push(symbol[p]);\n    }\n    return values.join('|');\n}\n"],"names":["fontCtx","document","createElement","getContext","ZERO_POINT","maptalks","Point","MarkerLayerClazz","DrawToolLayer","markerLayerClazz","renderer","getRendererClass","options","maxClusterRadius","textSumProperty","symbol","drawClusterText","textSymbol","animation","animationDuration","maxClusterZoom","noClusterWithOneMarker","forceRenderOnZooming","ClusterLayer","fromJSON","json","layer","geoJSONs","geometries","i","length","geo","Geometry","push","addGeometry","addMarker","markers","this","len","Marker","Error","super","apply","arguments","onConfig","conf","_getRenderer","render","identify","coordinate","map","getMap","maxZoom","getZoom","toJSON","call","getClusters","_currentClusters","mergeOptions","registerJSONType","defaultTextSymbol","textFaceName","textSize","textDx","textDy","defaultSymbol","markerType","markerFill","property","type","stops","markerFillOpacity","markerLineOpacity","markerLineWidth","markerLineColor","markerWidth","markerHeight","ClusterLayerRenderable","Base","init","_refreshStyle","_clusterNeedRedraw","checkResources","resources","_symbolResourceChecked","res","Util","getExternalResources","draw","canvas","prepareCanvas","zoom","checkMarksToDraw","clusters","_clearDataCache","_computeGrid","_triggerAnimate","_startAnimation","_animateDelta","_animateClusters","zoomClusters","_clusterCache","getClustersToDraw","_drawLayer","_parentClusters","dr","_inout","_player","Animation","animate","d","speed","easing","frame","styles","state","playState","setToRedraw","play","dirty","_markersToDraw","_geoList","oldMarkersToDraw","font","StringUtil","getFont","_textSymbol","digitLen","stringLength","toPoint","extent","getContainerExtent","pt","pExt","sprite","width","height","markerIndex","isMarkerDirty","p","_currentGrid","marker","_cluster","_getSprite","_prjToContainerPoint","PointExtent","sub","add","intersects","text","_getClusterText","x","y","_multi","drawOnInteracting","args","drawClusters","getCurrentNeedRenderGeos","_getCurrentNeedRenderGeos","forEachGeo","fn","context","forEach","g","onGeometryShow","onGeometryHide","onGeometryAdd","onGeometryRemove","onGeometryPositionChange","onRemove","point","coordinateToContainerPoint","old","c","distanceTo","center","getProjection","unproject","copy","children","slice","_hitGeos","onSymbolChanged","_stopAnim","argFn","_symbol","MapboxUtil","loadFunctionTypes","drawClustersFrame","drawMarkers","completeRender","drawGeos","parentClusters","toClusters","ratio","drawn","key","drawCluster","z","r","_getResolution","min","_markerExtent","getMin","pkey","Math","floor","parent","pp","cluster","op","ctx","opacity","globalAlpha","pos","offset","_sub","Canvas","image","prepareCanvasFont","textBaseline","dx","dy","fillText","_add","_spriteCache","values","join","getSymbolStamp","CanvasClass","_initGridSystem","points","isVisible","_getPrjCoordinates","_combine","_getPrjExtent","id","_getInternalId","geometry","_markerPoints","pre","getMinZoom","getMaxZoom","getCount","_computeZoomGrid","preT","preCache","sumProperty","grids","gx","gy","pgx","pgy","sumProp","getProperties","Coordinate","multi","sum","count","_mergeClusters","clusterMap","merging","visited","c1","c2","gxgy","split","ii","iii","_distanceTo","m","grid","toMerge","concat","sqrt","finish","onZoomStart","param","onZoomEnd","isEmpty","_zoomInClusters","ClusterLayerRenderer","VectorLayerCanvasRenderer","constructor","registerRenderer","PointLayerRenderer","ClusterGLRenderer","event","timestamp","parentContext","prototype","_clearToDraw","flush","pointCount","bufferIndex","opacityIndex","textIndex","data","willReadFrequently","getImageData","clusterSprites","textureDirty","pixelRatio","getDevicePixelRatio","spriteW","spriteH","addPoint","fontKey","fillStyle","_getTextSprite","clusterTextSprites","textTextureDirty","addTextPoint","_textSpriteCache","dpr","metrics","measureText","textWidth","textHeight","actualBoundingBoxAscent","actualBoundingBoxDescent","scale","debugCanvas","getElementById","drawImage","rebuildGeometries","_updateMesh","fbo","renderTarget","_clusterGeometry","setDrawCount","uniforms","resolution","layerOpacity","_getLayerOpacity","dxDy","_renderer","_spriteShader","_scene","_textGeometry","_textScene","isAtlasDirty","atlas","_genAtlas","_updateTexCoord","textAtlas","_genTextAtlas","_updateTextTexCoord","_updateGeometryData","_check","w","h","addVertex","sprites","positionBufferData","opacityBufferData","addTextVertex","textSprites","textPositionData","maxPointCount","texCoordBufferData","textTexCoordData","_initBuffers","updateData","positions","texCoordIndex","bin","tl","br","_fillTexCoord","textTexCoordIndex","_fillTextTexCoord","_initTexture","config","mag","premultiplyAlpha","_clusterTexture","update","device","texture","_clusterMesh","setUniform","_initTextTexture","_textTexture","_textMesh","texWidth","texHeight","u1","v1","u2","v2","addVertexTexCoord","addTextTexCoord","IconAtlas","RGBAImage","getVectorPacker","icons","iconMap","url","icon","isWebGL1","gl","WebGLRenderingContext","nonPowerOfTwo","texts","textMap","textSprite","putImageData","ImageData","Uint8ClampedArray","buffer","u","v","initContext","_initClusterShader","_initClusterMeshes","dispose","destroy","extraCommandProps","viewport","depth","enable","blend","func","src","dst","reshader","MeshShader","name","vert","frag","wgslVert","wgslFrag","spriteCluster","aPosition","aTexCoord","aOpacity","positionSize","generateBuffers","Mesh","Scene","Renderer","Float32Array","isNil"],"mappings":"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"}