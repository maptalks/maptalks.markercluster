{"version":3,"file":"maptalks.markercluster.js","sources":["../index.js"],"sourcesContent":["import * as maptalks from 'maptalks';\nimport { reshader } from '@maptalks/gl';\nimport { getVectorPacker, PointLayerRenderer } from '@maptalks/vt';\nimport vert from './glsl/sprite.vert';\nimport frag from './glsl/sprite.frag';\nimport wgslVert from './wgsl/sprite_vert.wgsl';\nimport wgslFrag from './wgsl/sprite_frag.wgsl';\n\nconst FONT_CANVAS = document.createElement('canvas');\nconst fontCtx = FONT_CANVAS.getContext('2d');\nconst ZERO_POINT = new maptalks.Point(0, 0);\n\nconst MarkerLayerClazz = maptalks.DrawToolLayer.markerLayerClazz;\nlet renderer = 'canvas';\nconst RendererClazz = MarkerLayerClazz.getRendererClass('canvas');\nif (!RendererClazz) {\n    renderer = 'gl';\n}\n\nconst options = {\n    'renderer': renderer,\n    'maxClusterRadius' : 160,\n    'textSumProperty' : null,\n    'symbol' : null,\n    'drawClusterText' : true,\n    'textSymbol' : null,\n    'animation' : true,\n    'animationDuration' : 450,\n    'maxClusterZoom' : null,\n    'noClusterWithOneMarker':true,\n    'forceRenderOnZooming' : true\n};\n\nexport class ClusterLayer extends MarkerLayerClazz {\n    /**\n     * Reproduce a ClusterLayer from layer's profile JSON.\n     * @param  {Object} json - layer's profile JSON\n     * @return {maptalks.ClusterLayer}\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(json) {\n        if (!json || json['type'] !== 'ClusterLayer') { return null; }\n        const layer = new ClusterLayer(json['id'], json['options']);\n        const geoJSONs = json['geometries'];\n        const geometries = [];\n        for (let i = 0; i < geoJSONs.length; i++) {\n            const geo = maptalks.Geometry.fromJSON(geoJSONs[i]);\n            if (geo) {\n                geometries.push(geo);\n            }\n        }\n        layer.addGeometry(geometries);\n        return layer;\n    }\n\n    addMarker(markers) {\n        return this.addGeometry(markers);\n    }\n\n    addGeometry(markers) {\n        for (let i = 0, len = markers.length; i < len; i++) {\n            if (!(markers[i] instanceof maptalks.Marker)) {\n                throw new Error('Only a point(Marker) can be added into a ClusterLayer');\n            }\n        }\n        return super.addGeometry.apply(this, arguments);\n    }\n\n    onConfig(conf) {\n        super.onConfig(conf);\n        if (conf['maxClusterRadius'] ||\n            conf['symbol'] ||\n            conf['drawClusterText'] ||\n            conf['textSymbol'] ||\n            conf['maxClusterZoom']) {\n            const renderer = this._getRenderer();\n            if (renderer) {\n                renderer.render();\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Identify the clusters on the given coordinate\n     * @param  {maptalks.Coordinate} coordinate   - coordinate to identify\n     * @return {Object|Geometry[]}  result: cluster { center : [cluster's center], children : [geometries in the cluster] } or markers\n     */\n    identify(coordinate, options) {\n        const map = this.getMap(),\n            maxZoom = this.options['maxClusterZoom'];\n        if (maxZoom && map && map.getZoom() > maxZoom) {\n            return super.identify(coordinate, options);\n        }\n        if (this._getRenderer()) {\n            return this._getRenderer().identify(coordinate, options);\n        }\n        return null;\n    }\n\n    /**\n     * Export the ClusterLayer's JSON.\n     * @return {Object} layer's JSON\n     */\n    toJSON() {\n        const json = super.toJSON.call(this);\n        json['type'] = 'ClusterLayer';\n        return json;\n    }\n    /**\n     * Get the ClusterLayer's current clusters\n     * @return {Object} layer's clusters\n     **/\n    getClusters() {\n        const renderer = this._getRenderer();\n        if (renderer) {\n            return renderer._currentClusters || [];\n        }\n        return [];\n    }\n}\n\n// merge to define ClusterLayer's default options.\nClusterLayer.mergeOptions(options);\n\n// register ClusterLayer's JSON type for JSON deserialization.\nClusterLayer.registerJSONType('ClusterLayer');\n\nconst defaultTextSymbol = {\n    'textFaceName'      : '\"microsoft yahei\"',\n    'textSize'          : 16,\n    'textDx'            : 0,\n    'textDy'            : 0\n};\n\nconst defaultSymbol = {\n    'markerType' : 'ellipse',\n    'markerFill' : { property:'count', type:'interval', stops: [[0, 'rgb(135, 196, 240)'], [9, '#1bbc9b'], [99, 'rgb(216, 115, 149)']] },\n    'markerFillOpacity' : 0.7,\n    'markerLineOpacity' : 1,\n    'markerLineWidth' : 3,\n    'markerLineColor' : '#fff',\n    'markerWidth' : { property:'count', type:'interval', stops: [[0, 40], [9, 60], [99, 80]] },\n    'markerHeight' : { property:'count', type:'interval', stops: [[0, 40], [9, 60], [99, 80]] }\n};\n\nconst ClusterLayerRenderable = function(Base) {\n    const renderable = class extends Base {\n        init() {\n            this._refreshStyle();\n            this._clusterNeedRedraw = true;\n        }\n\n        checkResources() {\n            if (!super.checkResources) {\n                return [];\n            }\n            const symbol = this.layer.options['symbol'] || defaultSymbol;\n            const resources = super.checkResources.apply(this, arguments);\n            if (symbol !== this._symbolResourceChecked) {\n                const res = maptalks.Util.getExternalResources(symbol, true);\n                if (res) {\n                    resources.push.apply(resources, res);\n                }\n                this._symbolResourceChecked = symbol;\n            }\n            return resources;\n        }\n\n        draw(timestamp, parentContext) {\n            if (!this.canvas) {\n                this.prepareCanvas();\n            }\n            const map = this.getMap();\n            const zoom = map.getZoom();\n            const maxClusterZoom = this.layer.options['maxClusterZoom'];\n            if (maxClusterZoom &&  zoom > maxClusterZoom) {\n                delete this._currentClusters;\n                this.checkMarksToDraw();\n                super.draw.apply(this, arguments);\n                return;\n            }\n            if (this._clusterNeedRedraw) {\n                this._clearDataCache();\n                this._computeGrid();\n                this._clusterNeedRedraw = false;\n            }\n            let clusters;\n            if (this._triggerAnimate) {\n                this._startAnimation(zoom);\n            }\n            if (this._animateDelta) {\n                clusters = this._animateClusters;\n            } else {\n                const zoomClusters = this._clusterCache[zoom] ? this._clusterCache[zoom]['clusters'] : null;\n                clusters = this.getClustersToDraw(zoomClusters);\n                clusters.zoom = zoom;\n            }\n            this._drawLayer(clusters, timestamp, parentContext);\n        }\n\n        _startAnimation(zoom) {\n            const zoomClusters = this._clusterCache[zoom] ? this._clusterCache[zoom]['clusters'] : null;\n            const clusters = this.getClustersToDraw(zoomClusters);\n            clusters.zoom = zoom;\n\n            this._animateClusters = clusters;\n            this._parentClusters = this._currentClusters || clusters;\n            const layer = this.layer;\n            if (layer.options['animation'] && this._triggerAnimate) {\n                let dr = [0, 1];\n                if (this._inout === 'in') {\n                    dr = [1, 0];\n                }\n                this._animateDelta = dr[0];\n                this._player = maptalks.animation.Animation.animate(\n                    { 'd' : dr },\n                    { 'speed' : layer.options['animationDuration'], 'easing' : 'inAndOut' },\n                    frame => {\n                        this._animateDelta = frame.styles.d;\n                        if (frame.state.playState === 'finished') {\n                            delete this._animateDelta;\n                            delete this._inout;\n                            delete this._animateClusters;\n                            delete this._parentClusters\n                        }\n                        this.setToRedraw();\n                    }\n                )\n                .play();\n                this.setToRedraw();\n            }\n            this._triggerAnimate = false;\n        }\n\n        checkMarksToDraw() {\n            const dirty = this._markersToDraw !== this.layer._geoList;\n            this._markersToDraw = this.layer._geoList;\n            this._markersToDraw.dirty = dirty;\n        }\n\n        getClustersToDraw(zoomClusters) {\n            const oldMarkersToDraw = this._markersToDraw || [];\n            this._markersToDraw = [];\n            const map = this.getMap();\n            const font = maptalks.StringUtil.getFont(this._textSymbol),\n                digitLen = maptalks.StringUtil.stringLength('9', font).toPoint();\n            const extent = map.getContainerExtent(),\n                clusters = [];\n            let pt, pExt, sprite, width, height, markerIndex = 0, isMarkerDirty = false;\n            for (const p in zoomClusters) {\n                this._currentGrid = zoomClusters[p];\n                if (zoomClusters[p]['count'] === 1 && this.layer.options['noClusterWithOneMarker']) {\n                    const marker = zoomClusters[p]['children'][0];\n                    marker._cluster = zoomClusters[p];\n                    if (!isMarkerDirty && oldMarkersToDraw[markerIndex++] !== marker) {\n                        isMarkerDirty = true;\n                    }\n                    this._markersToDraw.push(marker);\n                    continue;\n                }\n                sprite = this._getSprite().sprite;\n                width = sprite.canvas.width;\n                height = sprite.canvas.height;\n                pt = map._prjToContainerPoint(zoomClusters[p]['center']);\n                pExt = new maptalks.PointExtent(pt.sub(width, height), pt.add(width, height));\n                if (!extent.intersects(pExt)) {\n                    continue;\n                }\n                if (!zoomClusters[p]['textSize']) {\n                    const text = this._getClusterText(zoomClusters[p]);\n                    zoomClusters[p]['textSize'] = new maptalks.Point(digitLen.x * text.length, digitLen.y)._multi(1 / 2);\n                }\n                clusters.push(zoomClusters[p]);\n            }\n            if (oldMarkersToDraw.length !== this._markersToDraw.length) {\n                isMarkerDirty = true;\n            }\n            this._markersToDraw.dirty = isMarkerDirty;\n            return clusters;\n        }\n\n        drawOnInteracting(...args) {\n            if (this._currentClusters) {\n                this.drawClusters(this._currentClusters, 1);\n            }\n            super.drawOnInteracting(...args);\n        }\n\n        getCurrentNeedRenderGeos() {\n            if (this._markersToDraw) {\n                return this._markersToDraw;\n            }\n            return [];\n        }\n\n        _getCurrentNeedRenderGeos() {\n            return this.getCurrentNeedRenderGeos();\n        }\n\n        forEachGeo(fn, context) {\n            if (this._markersToDraw) {\n                this._markersToDraw.forEach((g) => {\n                    if (context) {\n                        fn.call(context, g);\n                    } else {\n                        fn(g);\n                    }\n                });\n            }\n        }\n\n        onGeometryShow() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryShow.apply(this, arguments);\n        }\n\n        onGeometryHide() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryHide.apply(this, arguments);\n        }\n\n        onGeometryAdd() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryAdd.apply(this, arguments);\n        }\n\n        onGeometryRemove() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryRemove.apply(this, arguments);\n        }\n\n        onGeometryPositionChange() {\n            this._clusterNeedRedraw = true;\n            super.onGeometryPositionChange.apply(this, arguments);\n        }\n\n        onRemove() {\n            this._clearDataCache();\n        }\n\n        identify(coordinate, options) {\n            const map = this.getMap(),\n                maxZoom = this.layer.options['maxClusterZoom'];\n            if (maxZoom && map.getZoom() > maxZoom) {\n                return super.identify(coordinate, options);\n            }\n            if (this._currentClusters) {\n                const point = map.coordinateToContainerPoint(coordinate);\n                const old = this._currentGrid;\n                for (let i = 0; i < this._currentClusters.length; i++) {\n                    const c = this._currentClusters[i];\n                    const pt = map._prjToContainerPoint(c['center']);\n                    this._currentGrid = c;\n                    const markerWidth = this._getSprite().sprite.canvas.width;\n\n                    if (point.distanceTo(pt) <= markerWidth) {\n                        return {\n                            'center'   : map.getProjection().unproject(c.center.copy()),\n                            'children' : c.children.slice(0)\n                        };\n                    }\n                }\n                this._currentGrid = old;\n            }\n\n            // if no clusters is hit, identify markers\n            if (this._markersToDraw && this._markersToDraw[0]) {\n                const point = map.coordinateToContainerPoint(coordinate);\n                return this.layer._hitGeos(this._markersToDraw, point, options);\n            }\n            return null;\n        }\n\n        onSymbolChanged() {\n            this._refreshStyle();\n            this._computeGrid();\n            this._stopAnim();\n            this.setToRedraw();\n        }\n\n        _refreshStyle() {\n            const symbol = this.layer.options['symbol'] || defaultSymbol;\n            const textSymbol = this.layer.options['textSymbol'] || defaultTextSymbol;\n            const argFn =  () => [this.getMap().getZoom(), this._currentGrid];\n            this._symbol = maptalks.MapboxUtil.loadFunctionTypes(symbol, argFn);\n            this._textSymbol = maptalks.MapboxUtil.loadFunctionTypes(textSymbol, argFn);\n        }\n\n        _drawLayer(clusters, timestamp, parentContext) {\n            this._currentClusters = clusters;\n            if (this._animateDelta >= 0) {\n                if (this._inout === 'in') {\n                    this.drawClustersFrame(clusters, this._parentClusters, this._animateDelta);\n                } else {\n                    this.drawClustersFrame(this._parentClusters, clusters, this._animateDelta);\n                }\n            } else {\n                this.drawClusters(clusters, 1);\n            }\n            this.drawMarkers(timestamp, parentContext);\n            this.completeRender();\n        }\n\n        drawMarkers() {\n            super.drawGeos();\n        }\n\n        drawClustersFrame(parentClusters, toClusters, ratio) {\n            this.prepareCanvas();\n            const map = this.getMap(),\n                drawn = {};\n            if (parentClusters) {\n                parentClusters.forEach(c => {\n                    const p = map._prjToContainerPoint(c['center']);\n                    if (!drawn[c.key]) {\n                        drawn[c.key] = 1;\n                        this.drawCluster(p, c, 1 - ratio);\n                    }\n                });\n            }\n            if (ratio === 0 || !toClusters) {\n                return;\n            }\n            const z = parentClusters.zoom,\n                r = map._getResolution(z) * this.layer.options['maxClusterRadius'],\n                min = this._markerExtent.getMin();\n            toClusters.forEach(c => {\n                let pt = map._prjToContainerPoint(c['center']);\n                const center = c.center;\n                const pgx = Math.floor((center.x - min.x) / r),\n                    pgy = Math.floor((center.y - min.y) / r);\n                const pkey = pgx + '_' + pgy;\n                const parent = this._clusterCache[z] ? this._clusterCache[z]['clusterMap'][pkey] : null;\n                if (parent) {\n                    const pp = map._prjToContainerPoint(parent['center']);\n                    pt = pp.add(pt.sub(pp)._multi(ratio));\n                }\n                this.drawCluster(pt, c, ratio > 0.5 ? 1 : ratio);\n            });\n        }\n\n        drawClusters(clusters, ratio) {\n            if (!clusters) {\n                return;\n            }\n            this.prepareCanvas();\n            const map = this.getMap();\n            clusters.forEach(c => {\n                const pt = map._prjToContainerPoint(c['center']);\n                this.drawCluster(pt, c, ratio > 0.5 ? 1 : ratio);\n            });\n\n        }\n\n        drawCluster(pt, cluster, op) {\n            this._currentGrid = cluster;\n            const ctx = this.context;\n            const sprite = this._getSprite().sprite;\n            const opacity = ctx.globalAlpha;\n            if (opacity * op === 0) {\n                return;\n            }\n            ctx.globalAlpha = opacity * op;\n            if (sprite) {\n                const pos = pt.add(sprite.offset)._sub(sprite.canvas.width / 2, sprite.canvas.height / 2);\n                maptalks.Canvas.image(ctx, sprite.canvas, pos.x, pos.y);\n            }\n\n            if (this.layer.options['drawClusterText'] && cluster['textSize']) {\n                maptalks.Canvas.prepareCanvasFont(ctx, this._textSymbol);\n                ctx.textBaseline = 'middle';\n                const dx = this._textSymbol['textDx'] || 0;\n                const dy = this._textSymbol['textDy'] || 0;\n                const text = this._getClusterText(cluster);\n                maptalks.Canvas.fillText(ctx, text, pt.sub(cluster['textSize'].x, 0)._add(dx, dy));\n            }\n            ctx.globalAlpha = opacity;\n        }\n\n        _getClusterText(cluster) {\n            const text = this.layer.options['textSumProperty'] ? cluster['textSumProperty'] : cluster['count'];\n            return text + '';\n        }\n\n        _getSprite() {\n            if (!this._spriteCache) {\n                this._spriteCache = {};\n            }\n            const key = getSymbolStamp(this._symbol);\n            if (!this._spriteCache[key]) {\n                this._spriteCache[key] = new maptalks.Marker([0, 0], { 'symbol' : this._symbol })._getSprite(this.resources, this.getMap().CanvasClass);\n            }\n            return {\n                sprite: this._spriteCache[key],\n                key\n            };\n        }\n\n        _initGridSystem() {\n            const points = [];\n            let extent, c;\n            this.layer.forEach(g => {\n                if (!g.isVisible()) {\n                    return;\n                }\n                c = g._getPrjCoordinates();\n                if (!extent) {\n                    extent = g._getPrjExtent();\n                } else {\n                    extent = extent._combine(g._getPrjExtent());\n                }\n                points.push({\n                    x : c.x,\n                    y : c.y,\n                    id : g._getInternalId(),\n                    geometry : g\n                });\n            });\n            this._markerExtent = extent;\n            this._markerPoints = points;\n        }\n\n        _computeGrid() {\n            const map = this.getMap(),\n                zoom = map.getZoom();\n            if (!this._markerExtent) {\n                this._initGridSystem();\n            }\n            if (!this._clusterCache) {\n                this._clusterCache = {};\n            }\n            const pre = map._getResolution(map.getMinZoom()) > map._getResolution(map.getMaxZoom()) ? zoom - 1 : zoom + 1;\n            if (this._clusterCache[pre] && this._clusterCache[pre].length === this.layer.getCount()) {\n                this._clusterCache[zoom] = this._clusterCache[pre];\n            }\n            if (!this._clusterCache[zoom]) {\n                this._clusterCache[zoom] = this._computeZoomGrid(zoom);\n            }\n        }\n\n        _computeZoomGrid(zoom) {\n            if (!this._markerExtent) {\n                return null;\n            }\n            const map = this.getMap(),\n                r = map._getResolution(zoom) * this.layer.options['maxClusterRadius'],\n                preT = map._getResolution(zoom - 1) ? map._getResolution(zoom - 1) * this.layer.options['maxClusterRadius'] : null;\n            let preCache = this._clusterCache[zoom - 1];\n            if (!preCache && zoom - 1 >= map.getMinZoom()) {\n                this._clusterCache[zoom - 1] = preCache = this._computeZoomGrid(zoom - 1);\n            }\n            // 1. format extent of markers to grids with raidus of r\n            // 2. find point's grid in the grids\n            // 3. sum up the point into the grid's collection\n            const points = this._markerPoints;\n            const sumProperty = this.layer.options['textSumProperty'];\n            const grids = {},\n                min = this._markerExtent.getMin();\n            let gx, gy, key,\n                pgx, pgy, pkey;\n            for (let i = 0, len = points.length; i < len; i++) {\n                const geo = points[i].geometry;\n                let sumProp = 0;\n\n                if (sumProperty && geo.getProperties() && geo.getProperties()[sumProperty]) {\n                    sumProp = geo.getProperties()[sumProperty];\n                }\n\n                gx = Math.floor((points[i].x - min.x) / r);\n                gy = Math.floor((points[i].y - min.y) / r);\n                key = gx + '_' + gy;\n                if (!grids[key]) {\n                    grids[key] = {\n                        'sum' : new maptalks.Coordinate(points[i].x, points[i].y),\n                        'center' : new maptalks.Coordinate(points[i].x, points[i].y),\n                        'count' : 1,\n                        'textSumProperty' : sumProp,\n                        'children' :[geo],\n                        'key' : key + ''\n                    };\n                    if (preT && preCache) {\n                        pgx = Math.floor((points[i].x - min.x) / preT);\n                        pgy = Math.floor((points[i].y - min.y) / preT);\n                        pkey = pgx + '_' + pgy;\n                        grids[key]['parent'] = preCache['clusterMap'][pkey];\n                    }\n                } else {\n\n                    grids[key]['sum']._add(new maptalks.Coordinate(points[i].x, points[i].y));\n                    grids[key]['count']++;\n                    grids[key]['center'] = grids[key]['sum'].multi(1 / grids[key]['count']);\n                    grids[key]['children'].push(geo);\n                    grids[key]['textSumProperty'] += sumProp;\n                }\n            }\n            return this._mergeClusters(grids, r / 2);\n        }\n\n        _mergeClusters(grids, r) {\n            const clusterMap = {};\n            for (const p in grids) {\n                clusterMap[p] = grids[p];\n            }\n\n            // merge adjacent clusters\n            const merging = {};\n\n            const visited = {};\n            // find clusters need to merge\n            let c1, c2;\n            for (const p in grids) {\n                c1 = grids[p];\n                if (visited[c1.key]) {\n                    continue;\n                }\n                const gxgy = c1.key.split('_');\n                const gx = +(gxgy[0]),\n                    gy = +(gxgy[1]);\n                //traverse adjacent grids\n                for (let ii = -1; ii <= 1; ii++) {\n                    for (let iii = -1; iii <= 1; iii++) {\n                        if (ii === 0 && iii === 0) {\n                            continue;\n                        }\n                        const key2 = (gx + ii) + '_' + (gy + iii);\n                        c2 = grids[key2];\n                        if (c2 && this._distanceTo(c1['center'], c2['center']) <= r) {\n                            if (!merging[c1.key]) {\n                                merging[c1.key] = [];\n                            }\n                            merging[c1.key].push(c2);\n                            visited[c2.key] = 1;\n                        }\n                    }\n                }\n            }\n\n            //merge clusters\n            for (const m in merging) {\n                const grid = grids[m];\n                if (!grid) {\n                    continue;\n                }\n                const toMerge = merging[m];\n                for (let i = 0; i < toMerge.length; i++) {\n                    if (grids[toMerge[i].key]) {\n                        grid['sum']._add(toMerge[i].sum);\n                        grid['count'] += toMerge[i].count;\n                        grid['textSumProperty'] += toMerge[i].textSumProperty;\n                        grid['children'] = grid['children'].concat(toMerge[i].children);\n                        clusterMap[toMerge[i].key] = grid;\n                        delete grids[toMerge[i].key];\n                    }\n                }\n                grid['center'] = grid['sum'].multi(1 / grid['count']);\n            }\n\n            return {\n                'clusters' : grids,\n                'clusterMap' : clusterMap\n            };\n        }\n\n        _distanceTo(c1, c2) {\n            const x = c1.x - c2.x,\n                y = c1.y - c2.y;\n            return Math.sqrt(x * x + y * y);\n        }\n\n        _stopAnim() {\n            if (this._player && this._player.playState !== 'finished') {\n                this._player.finish();\n            }\n        }\n\n        onZoomStart(param) {\n            this._stopAnim();\n            super.onZoomStart(param);\n        }\n\n        onZoomEnd(param) {\n            if (this.layer.isEmpty() || !this.layer.isVisible()) {\n                super.onZoomEnd.apply(this, arguments);\n                return;\n            }\n            this._inout = param['from'] > param['to'] ? 'in' : 'out';\n            this._triggerAnimate = true;\n            this._computeGrid();\n            super.onZoomEnd.apply(this, arguments);\n        }\n\n        _clearDataCache() {\n            this._stopAnim();\n            delete this._markerExtent;\n            delete this._markerPoints;\n            delete this._clusterCache;\n            delete this._zoomInClusters;\n        }\n    };\n    return renderable;\n}\n\nclass ClusterLayerRenderer extends ClusterLayerRenderable(maptalks.renderer.VectorLayerCanvasRenderer) {\n\n    constructor(...args) {\n        super(...args);\n        this.init();\n    }\n}\n\nClusterLayer.registerRenderer('canvas', ClusterLayerRenderer);\n\nif (typeof PointLayerRenderer !== 'undefined') {\n    class ClusterGLRenderer extends ClusterLayerRenderable(PointLayerRenderer) {\n        constructor(...args) {\n            super(...args);\n            this.init();\n        }\n\n        drawOnInteracting(event, timestamp, parentContext) {\n            if (this._currentClusters) {\n                this.drawClusters(this._currentClusters, 1);\n            }\n            this.drawMarkers(timestamp, parentContext);\n            // PointLayerRenderer.prototype.draw.call(this, timestamp, parentContext);\n        }\n\n        drawClusters(...args) {\n            this._clearToDraw();\n            super.drawClusters(...args);\n            this.flush();\n        }\n\n        drawClustersFrame(...args) {\n            this._clearToDraw();\n            super.drawClustersFrame(...args);\n            this.flush();\n        }\n\n        _clearToDraw() {\n            this.pointCount = 0;\n            this.bufferIndex = 0;\n            this.opacityIndex = 0;\n            this.textIndex = 0;\n        }\n\n        drawCluster(pt, cluster, opacity) {\n            this._currentGrid = cluster;\n            const { sprite, key } = this._getSprite();\n            const canvas = sprite.canvas;\n            if (!sprite.data) {\n                sprite.data = canvas.getContext('2d', { willReadFrequently: true }).getImageData(0, 0, canvas.width, canvas.height);\n            }\n            if (!this.clusterSprites[key]) {\n                this.clusterSprites[key] = sprite;\n                this.textureDirty = true;\n            }\n            const pos = pt.add(sprite.offset)._sub(canvas.width / 2, canvas.height / 2);\n            let x = pos.x;\n            let y = pos.y;\n            const map = this.getMap();\n            const pixelRatio = map.getDevicePixelRatio();\n            const height = map.height;\n            x = x * pixelRatio;\n            y = (height - y) * pixelRatio;\n            const spriteW = sprite.data.width * pixelRatio;\n            const spriteH = sprite.data.height * pixelRatio;\n\n            this.addPoint(x, y, spriteW, spriteH, opacity, key);\n\n            if (this.layer.options['drawClusterText']) {\n                maptalks.Canvas.prepareCanvasFont(fontCtx, this._textSymbol);\n                const fontKey = fontCtx.font + '-' + fontCtx.fillStyle;\n                const text = this._getClusterText(cluster);\n                const { sprite, key } = this._getTextSprite(text, fontKey);\n                if (!this.clusterTextSprites[key]) {\n                    this.clusterTextSprites[key] = sprite;\n                    this.textTextureDirty = true;\n                }\n                this.addTextPoint(x + spriteW / 2, y - spriteH / 2, sprite.data.width * pixelRatio, sprite.data.height * pixelRatio, key);\n            }\n            this.pointCount++;\n\n        }\n\n        _getTextSprite(text, fontKey) {\n            if (!this._textSpriteCache) {\n                this._textSpriteCache = {};\n            }\n            const key = fontKey + '-' + text;\n            if (!this._textSpriteCache[key]) {\n                const dpr = this.getMap().getDevicePixelRatio();\n                const metrics = fontCtx.measureText(text);\n                const textWidth = metrics.width;\n                const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n                const canvas = document.createElement('canvas');\n                canvas.width = textWidth * dpr;\n                canvas.height = textHeight * dpr;\n                const ctx = canvas.getContext('2d', { willReadFrequently: true });\n                ctx.scale(dpr, dpr);\n                maptalks.Canvas.prepareCanvasFont(ctx, this._textSymbol);\n                ctx.textBaseline = 'top';\n                ctx.fillText(text, 0, 0);\n                const debugCanvas = document.getElementById('debug-text-sprite');\n                if (debugCanvas) {\n                    debugCanvas.width = canvas.width;\n                    debugCanvas.height = canvas.height;\n                    const ctx = debugCanvas.getContext('2d');\n                    ctx.drawImage(canvas, 0, 0);\n                }\n\n                this._textSpriteCache[key] = {\n                    canvas,\n                    offset: ZERO_POINT,\n                    data: ctx.getImageData(0, 0, canvas.width, canvas.height)\n                };\n            }\n            return {\n                sprite: this._textSpriteCache[key],\n                key\n            };\n        }\n\n        checkMarksToDraw() {\n            super.checkMarksToDraw();\n            this._checkToRebuildGeometry();\n        }\n\n        drawMarkers(timestamp, parentContext) {\n            this._checkToRebuildGeometry();\n            PointLayerRenderer.prototype.draw.call(this, timestamp, parentContext);\n        }\n\n        _checkToRebuildGeometry() {\n            // only rebuild when not animating or interacting\n            if (this._markersToDraw.dirty && !this.isInteractingOrAnimating()) {\n                this.rebuildGeometries();\n                this._markersToDraw.dirty = false;\n            }\n        }\n\n        isInteractingOrAnimating() {\n            return this.getMap().isInteracting() || this._animateDelta >= 0;\n        }\n\n        flush(parentContext) {\n            if (this.pointCount === 0) {\n                return;\n            }\n            this._updateMesh();\n            const fbo = parentContext && parentContext.renderTarget && context.renderTarget.fbo;\n            this._clusterGeometry.setDrawCount(this.pointCount * 6);\n            const { width, height } = this.canvas;\n            const layerOpacity = this._getLayerOpacity();\n            const uniforms = {\n                resolution: [width, height],\n                layerOpacity,\n                dxDy: [0, 0]\n            };\n            this._renderer.render(this._spriteShader, uniforms, this._scene, fbo);\n\n            if (this.layer.options['drawClusterText']) {\n                this._textGeometry.setDrawCount(this.pointCount * 6);\n                const dx = this._textSymbol['textDx'] || 0;\n                const dy = this._textSymbol['textDy'] || 0;\n                uniforms.dxDy = [dx, dy];\n                this._renderer.render(this._spriteShader, uniforms, this._textScene, fbo);\n            }\n        }\n\n        _updateMesh() {\n\n            const isAtlasDirty = this.textureDirty;\n            const atlas = this._genAtlas();\n            this._updateTexCoord(atlas, isAtlasDirty);\n            // text\n            if (this.layer.options['drawClusterText']) {\n                const isAtlasDirty = this.textTextureDirty;\n                const textAtlas = this._genTextAtlas();\n                this._updateTextTexCoord(textAtlas, isAtlasDirty);\n            }\n\n            this._updateGeometryData();\n        }\n\n        addPoint(x, y, width, height, opacity, key) {\n            this._check();\n            const w = width;\n            const h = height;\n\n            this.addVertex(x, y - h, opacity);\n            this.addVertex(x + w, y - h, opacity);\n            this.addVertex(x, y, opacity);\n            this.addVertex(x, y, opacity);\n            this.addVertex(x + w, y - h, opacity);\n            this.addVertex(x + w, y, opacity);\n            if (this.sprites[this.pointCount] !== key) {\n                this.sprites[this.pointCount] = key;\n                this.sprites.dirty = true;\n            }\n        }\n\n        addVertex(x, y, opacity) {\n            const positionBufferData = this.positionBufferData;\n            if (positionBufferData[this.bufferIndex] !== x) {\n                positionBufferData[this.bufferIndex] = x;\n                positionBufferData.dirty = true;\n            }\n            this.bufferIndex++;\n            if (positionBufferData[this.bufferIndex] !== y) {\n                positionBufferData[this.bufferIndex] = y;\n                positionBufferData.dirty = true;\n            }\n            this.bufferIndex++;\n\n            const opacityBufferData = this.opacityBufferData;\n            // opacity *= 255;\n            // U8[0] = opacity;\n            if (opacityBufferData[this.opacityIndex] !== opacity) {\n                opacityBufferData[this.opacityIndex] = opacity;\n                opacityBufferData.dirty = true;\n            }\n            this.opacityIndex++;\n        }\n\n        addTextPoint(x, y, width, height, key) {\n            this._check();\n            const dpr = this.getMap().getDevicePixelRatio();\n            width /= dpr;\n            height /= dpr;\n            const w = width / 2;\n            const h = height / 2;\n\n            this.addTextVertex(x - w, y - h);\n            this.addTextVertex(x + w, y - h);\n            this.addTextVertex(x - w, y + h);\n            this.addTextVertex(x - w, y + h);\n            this.addTextVertex(x + w, y - h);\n            this.addTextVertex(x + w, y + h);\n\n            if (this.textSprites[this.pointCount] !== key) {\n                this.textSprites[this.pointCount] = key;\n                this.textSprites.dirty = true;\n            }\n        }\n\n        addTextVertex(x, y) {\n            const textPositionData = this.textPositionData;\n            if (textPositionData[this.textIndex] !== x) {\n                textPositionData[this.textIndex] = x;\n                textPositionData.dirty = true;\n            }\n            this.textIndex++;\n            if (textPositionData[this.textIndex] !== y) {\n                textPositionData[this.textIndex] = y;\n                textPositionData.dirty = true;\n            }\n            this.textIndex++;\n        }\n\n        _check() {\n            if (this.pointCount >= this.maxPointCount - 1) {\n                this.maxPointCount += 1024;\n                const { positionBufferData, texCoordBufferData, opacityBufferData, textPositionData, textTexCoordData } = this._initBuffers();\n                for (let i = 0; i < this.bufferIndex; i++) {\n                    positionBufferData[i] = this.positionBufferData[i];\n                    texCoordBufferData[i] = this.texCoordBufferData[i];\n                    textPositionData[i] = this.textPositionData[i];\n                    textTexCoordData[i] = this.textTexCoordData[i];\n                }\n                for (let i = 0; i < this.opacityIndex; i++) {\n                    opacityBufferData[i] = this.opacityBufferData[i];\n                }\n                this.positionBufferData = positionBufferData;\n                this.texCoordBufferData = texCoordBufferData;\n                this.opacityBufferData = opacityBufferData;\n                this.textPositionData = textPositionData;\n                this.textTexCoordData = textTexCoordData;\n            }\n        }\n\n        _updateGeometryData() {\n            // icon\n            if (this.positionBufferData.dirty) {\n                this._clusterGeometry.updateData('aPosition', this.positionBufferData);\n                // console.log(this.positionBufferData);\n                this.positionBufferData.dirty = false;\n            }\n            if (this.opacityBufferData.dirty) {\n                this._clusterGeometry.updateData('aOpacity', this.opacityBufferData);\n                this._textGeometry.updateData('aOpacity', this.opacityBufferData);\n                this.opacityBufferData.dirty = false;\n            }\n            if (this.texCoordBufferData.dirty) {\n                this._clusterGeometry.updateData('aTexCoord', this.texCoordBufferData);\n                this.texCoordBufferData.dirty = false;\n            }\n\n            // text\n            if (this.textPositionData.dirty) {\n                this._textGeometry.updateData('aPosition', this.textPositionData);\n                this.textPositionData.dirty = false;\n            }\n            if (this.textTexCoordData.dirty) {\n                this._textGeometry.updateData('aTexCoord', this.textTexCoordData);\n                this.textTexCoordData.dirty = false;\n            }\n        }\n\n        _updateTexCoord(atlas, isAtlasDirty) {\n            if (!this.sprites.dirty && !isAtlasDirty) {\n                return;\n            }\n            const { positions, image } = atlas;\n            const { width, height } = image;\n            this.texCoordIndex = 0;\n            for (let i = 0; i < this.pointCount; i++) {\n                const bin = positions[this.sprites[i]];\n                const { tl, br } = bin;\n                this._fillTexCoord(tl, br, width, height);\n            }\n            this.sprites.dirty = false;\n        }\n\n        _updateTextTexCoord(atlas, isAtlasDirty) {\n            if (!this.textSprites.dirty && !isAtlasDirty) {\n                return;\n            }\n            const { positions, image } = atlas;\n            const { width, height } = image;\n            this.textTexCoordIndex = 0;\n            for (let i = 0; i < this.pointCount; i++) {\n                const bin = positions[this.textSprites[i]];\n                const { tl, br } = bin;\n                this._fillTextTexCoord(tl, br, width, height);\n            }\n            this.textSprites.dirty = false;\n        }\n\n        _initTexture(data, width, height) {\n            const config = {\n                data,\n                width,\n                height,\n                mag: 'linear',\n                min: 'linear',\n                premultiplyAlpha: true\n            };\n            if (this._clusterTexture) {\n                if (this._clusterTexture.update) {\n                    this._clusterTexture.update(config);\n                } else {\n                    this._clusterTexture(config);\n                }\n            } else {\n                this._clusterTexture = this.device.texture(config);\n            }\n            this._clusterMesh.setUniform('sourceTexture', this._clusterTexture);\n        }\n\n        _initTextTexture(data, width, height) {\n            const config = {\n                data,\n                width,\n                height,\n                mag: 'linear',\n                min: 'linear',\n                premultiplyAlpha: true\n            };\n            if (this._textTexture) {\n                if (this._textTexture.update) {\n                    this._textTexture.update(config);\n                } else {\n                    this._textTexture(config);\n                }\n            } else {\n                this._textTexture = this.device.texture(config);\n            }\n            this._textMesh.setUniform('sourceTexture', this._textTexture);\n        }\n\n        _fillTexCoord(tl, br, texWidth, texHeight) {\n            const u1 = tl[0] / texWidth;\n            const v1 = br[1] / texHeight;\n            const u2 = br[0] / texWidth;\n            const v2 = tl[1] / texHeight;\n\n            this.addVertexTexCoord(u1, v1);\n            this.addVertexTexCoord(u2, v1);\n            this.addVertexTexCoord(u1, v2);\n            this.addVertexTexCoord(u1, v2);\n            this.addVertexTexCoord(u2, v1);\n            this.addVertexTexCoord(u2, v2);\n        }\n\n        _fillTextTexCoord(tl, br, texWidth, texHeight) {\n            const u1 = tl[0] / texWidth;\n            const v1 = br[1] / texHeight;\n            const u2 = br[0] / texWidth;\n            const v2 = tl[1] / texHeight;\n\n            this.addTextTexCoord(u1, v1);\n            this.addTextTexCoord(u2, v1);\n            this.addTextTexCoord(u1, v2);\n            this.addTextTexCoord(u1, v2);\n            this.addTextTexCoord(u2, v1);\n            this.addTextTexCoord(u2, v2);\n        }\n\n        _genAtlas() {\n            if (!this.textureDirty) {\n                return this.atlas;\n            }\n            const { IconAtlas, RGBAImage } = getVectorPacker();\n            const icons = this.clusterSprites;\n            const iconMap = {};\n            for (const url in icons) {\n                const icon = icons[url];\n                const { width, height, data } = icon.data;\n                const image = new RGBAImage({ width, height }, data);\n                iconMap[url] = { data: image, pixelRatio: 1 };\n            }\n            const isWebGL1 = this.gl && (this.gl instanceof WebGLRenderingContext);\n            this.atlas = new IconAtlas(iconMap, { nonPowerOfTwo: !isWebGL1 });\n            this.textureDirty = false;\n            const { image } = this.atlas;\n            const { width, height } = image;\n            this._initTexture(image.data, width, height);\n            return this.atlas;\n        }\n\n        _genTextAtlas() {\n            if (!this.textTextureDirty) {\n                return this.textAtlas;\n            }\n            const { IconAtlas, RGBAImage } = getVectorPacker();\n            const texts = this.clusterTextSprites;\n            const textMap = {};\n            for (const key in texts) {\n                const textSprite = texts[key];\n                const { width, height, data } = textSprite.data;\n                const image = new RGBAImage({ width, height }, data);\n                textMap[key] = { data: image, pixelRatio: 1 };\n            }\n            const isWebGL1 = this.gl && (this.gl instanceof WebGLRenderingContext);\n            this.textAtlas = new IconAtlas(textMap, { nonPowerOfTwo: !isWebGL1 });\n            const { image } = this.textAtlas;\n            const { width, height } = image;\n            this._initTextTexture(image.data, width, height);\n            this.textTextureDirty = false;\n\n            const debugCanvas = document.getElementById('debug-text-atlas');\n            if (debugCanvas) {\n                debugCanvas.width = width;\n                debugCanvas.height = height;\n                const ctx = debugCanvas.getContext('2d');\n                ctx.putImageData(new ImageData(new Uint8ClampedArray(image.data.buffer), width, height), 0, 0);\n            }\n\n            return this.textAtlas;\n        }\n\n        addVertexTexCoord(u, v) {\n            const texCoordBufferData = this.texCoordBufferData;\n            if (texCoordBufferData[this.texCoordIndex] !== u) {\n                texCoordBufferData[this.texCoordIndex] = u;\n                texCoordBufferData.dirty = true;\n            }\n            this.texCoordIndex++;\n            if (texCoordBufferData[this.texCoordIndex] !== v) {\n                texCoordBufferData[this.texCoordIndex] = v;\n                texCoordBufferData.dirty = true;\n            }\n            this.texCoordIndex++;\n        }\n\n        addTextTexCoord(u, v) {\n            const textTexCoordData = this.textTexCoordData;\n            if (textTexCoordData[this.textTexCoordIndex] !== u) {\n                textTexCoordData[this.textTexCoordIndex] = u;\n                textTexCoordData.dirty = true;\n            }\n            this.textTexCoordIndex++;\n            if (textTexCoordData[this.textTexCoordIndex] !== v) {\n                textTexCoordData[this.textTexCoordIndex] = v;\n                textTexCoordData.dirty = true;\n            }\n            this.textTexCoordIndex++;\n        }\n\n        initContext() {\n            // this.\n            this._initClusterShader();\n            this._initClusterMeshes();\n            return super.initContext();\n        }\n\n        onRemove() {\n            if (this._spriteShader) {\n                this._spriteShader.dispose();\n                delete this._spriteShader;\n            }\n            if (this._clusterMesh) {\n                this._clusterMesh.dispose();\n                delete this._clusterMesh;\n            }\n            if (this._clusterGeometry) {\n                this._clusterGeometry.dispose();\n                delete this._clusterGeometry;\n            }\n            if (this._textMesh) {\n                this._textMesh.dispose();\n                delete this._textMesh;\n            }\n            if (this._textGeometry) {\n                this._textGeometry.dispose();\n                delete this._textGeometry;\n            }\n            if (this._clusterTexture) {\n                this._clusterTexture.destroy();\n                delete this._clusterTexture;\n            }\n            if (this._textTexture) {\n                this._textTexture.destroy();\n                delete this._textTexture;\n            }\n            return super.onRemove();\n        }\n\n        _initClusterShader() {\n            const viewport = {\n                x : 0,\n                y : 0,\n                width : () => {\n                    return this.canvas ? this.canvas.width : 1;\n                },\n                height : () => {\n                    return this.canvas ? this.canvas.height : 1;\n                }\n            };\n\n            const extraCommandProps = {\n                viewport,\n                depth: {\n                    enable: false\n                },\n                blend: {\n                    enable: true,\n                    func: {\n                        src: 1,\n                        dst: 'one minus src alpha'\n                    }\n                }\n            };\n\n            this._spriteShader = new reshader.MeshShader({\n                name: 'cluster-sprite',\n                vert,\n                frag,\n                wgslVert,\n                wgslFrag,\n                extraCommandProps\n            });\n        }\n\n        _initClusterMeshes() {\n            this.maxPointCount = 1024;\n            this.pointCount = 0;\n            this.clusterSprites = {};\n            this.clusterTextSprites = {};\n            this.sprites = [];\n            this.textSprites = [];\n            this.spriteCluster = [];\n\n            const {\n                positionBufferData, texCoordBufferData, opacityBufferData,\n                textPositionData, textTexCoordData\n            } = this._initBuffers();\n            this.positionBufferData = positionBufferData;\n            this.texCoordBufferData = texCoordBufferData;\n            this.opacityBufferData = opacityBufferData;\n            this.textPositionData = textPositionData;\n            this.textTexCoordData = textTexCoordData;\n\n            this._clusterGeometry = new reshader.Geometry({\n                aPosition: this.positionBufferData,\n                aTexCoord: this.texCoordBufferData,\n                aOpacity: this.opacityBufferData\n            }, null, 0, {\n                positionSize: 2\n            });\n            this._clusterGeometry.generateBuffers(this.device);\n            this._clusterMesh = new reshader.Mesh(this._clusterGeometry);\n            this._scene = new reshader.Scene([this._clusterMesh]);\n\n            this._textGeometry = new reshader.Geometry({\n                aPosition: this.textPositionData,\n                aTexCoord: this.textTexCoordData,\n                aOpacity: this.opacityBufferData\n            }, null, 0, {\n                positionSize: 2\n            });\n            this._textGeometry.generateBuffers(this.device);\n            this._textMesh = new reshader.Mesh(this._textGeometry);\n            this._textScene = new reshader.Scene([this._textMesh]);\n\n            this._renderer = new reshader.Renderer(this.device);\n        }\n\n        _initBuffers() {\n            const vertexSize = 2;\n            const texCoordSize = 2;\n            const opacitySize = 1;\n\n            const positionBufferData = new Float32Array(this.maxPointCount * vertexSize * 6);\n            const texCoordBufferData = new Float32Array(this.maxPointCount * texCoordSize * 6);\n            const opacityBufferData = new Float32Array(this.maxPointCount * opacitySize * 6);\n            // opacityBufferData.fill(255);\n\n            const textPositionData = new Float32Array(this.maxPointCount * vertexSize * 6);\n            const textTexCoordData = new Float32Array(this.maxPointCount * texCoordSize * 6);\n\n            return { positionBufferData, texCoordBufferData, opacityBufferData, textPositionData, textTexCoordData };\n        }\n\n        _getLayerOpacity() {\n            let layerOpacity = this.layer && this.layer.options['opacity'];\n            if (maptalks.Util.isNil(layerOpacity)) {\n                layerOpacity = 1;\n            }\n            return layerOpacity;\n        }\n    }\n    ClusterLayer.registerRenderer('gl', ClusterGLRenderer);\n    ClusterLayer.registerRenderer('gpu', ClusterGLRenderer);\n}\n\nfunction getSymbolStamp(symbol) {\n    const values = [];\n    for (const p in symbol) {\n        if (p[0] === '_') {\n            continue;\n        }\n        values.push(symbol[p]);\n    }\n    return values.join('|');\n}\n"],"names":["fontCtx","document","createElement","getContext","ZERO_POINT","maptalks","Point","MarkerLayerClazz","DrawToolLayer","markerLayerClazz","renderer","getRendererClass","options","maxClusterRadius","textSumProperty","symbol","drawClusterText","textSymbol","animation","animationDuration","maxClusterZoom","noClusterWithOneMarker","forceRenderOnZooming","ClusterLayer","fromJSON","json","layer","geoJSONs","geometries","i","length","geo","Geometry","push","addGeometry","addMarker","markers","this","len","Marker","Error","super","apply","arguments","onConfig","conf","_getRenderer","render","identify","coordinate","map","getMap","maxZoom","getZoom","toJSON","call","getClusters","_currentClusters","mergeOptions","registerJSONType","defaultTextSymbol","textFaceName","textSize","textDx","textDy","defaultSymbol","markerType","markerFill","property","type","stops","markerFillOpacity","markerLineOpacity","markerLineWidth","markerLineColor","markerWidth","markerHeight","ClusterLayerRenderable","Base","init","_refreshStyle","_clusterNeedRedraw","checkResources","resources","_symbolResourceChecked","res","Util","getExternalResources","draw","timestamp","parentContext","canvas","prepareCanvas","zoom","checkMarksToDraw","clusters","_clearDataCache","_computeGrid","_triggerAnimate","_startAnimation","_animateDelta","_animateClusters","zoomClusters","_clusterCache","getClustersToDraw","_drawLayer","_parentClusters","dr","_inout","_player","Animation","animate","d","speed","easing","frame","styles","state","playState","setToRedraw","play","dirty","_markersToDraw","_geoList","oldMarkersToDraw","font","StringUtil","getFont","_textSymbol","digitLen","stringLength","toPoint","extent","getContainerExtent","pt","pExt","sprite","width","height","markerIndex","isMarkerDirty","p","_currentGrid","marker","_cluster","_getSprite","_prjToContainerPoint","PointExtent","sub","add","intersects","text","_getClusterText","x","y","_multi","drawOnInteracting","args","drawClusters","getCurrentNeedRenderGeos","_getCurrentNeedRenderGeos","forEachGeo","fn","context","forEach","g","onGeometryShow","onGeometryHide","onGeometryAdd","onGeometryRemove","onGeometryPositionChange","onRemove","point","coordinateToContainerPoint","old","c","distanceTo","center","getProjection","unproject","copy","children","slice","_hitGeos","onSymbolChanged","_stopAnim","argFn","_symbol","MapboxUtil","loadFunctionTypes","drawClustersFrame","drawMarkers","completeRender","drawGeos","parentClusters","toClusters","ratio","drawn","key","drawCluster","z","r","_getResolution","min","_markerExtent","getMin","pkey","Math","floor","parent","pp","cluster","op","ctx","opacity","globalAlpha","pos","offset","_sub","Canvas","image","prepareCanvasFont","textBaseline","dx","dy","fillText","_add","_spriteCache","values","join","getSymbolStamp","CanvasClass","_initGridSystem","points","isVisible","_getPrjCoordinates","_combine","_getPrjExtent","id","_getInternalId","geometry","_markerPoints","pre","getMinZoom","getMaxZoom","getCount","_computeZoomGrid","preT","preCache","sumProperty","grids","gx","gy","pgx","pgy","sumProp","getProperties","Coordinate","multi","sum","count","_mergeClusters","clusterMap","merging","visited","c1","c2","gxgy","split","ii","iii","_distanceTo","m","grid","toMerge","concat","sqrt","finish","onZoomStart","param","onZoomEnd","isEmpty","_zoomInClusters","ClusterLayerRenderer","VectorLayerCanvasRenderer","constructor","registerRenderer","PointLayerRenderer","ClusterGLRenderer","event","_clearToDraw","flush","pointCount","bufferIndex","opacityIndex","textIndex","data","willReadFrequently","getImageData","clusterSprites","textureDirty","pixelRatio","getDevicePixelRatio","spriteW","spriteH","addPoint","fontKey","fillStyle","_getTextSprite","clusterTextSprites","textTextureDirty","addTextPoint","_textSpriteCache","dpr","metrics","measureText","textWidth","textHeight","actualBoundingBoxAscent","actualBoundingBoxDescent","scale","debugCanvas","getElementById","drawImage","_checkToRebuildGeometry","prototype","isInteractingOrAnimating","rebuildGeometries","isInteracting","_updateMesh","fbo","renderTarget","_clusterGeometry","setDrawCount","uniforms","resolution","layerOpacity","_getLayerOpacity","dxDy","_renderer","_spriteShader","_scene","_textGeometry","_textScene","isAtlasDirty","atlas","_genAtlas","_updateTexCoord","textAtlas","_genTextAtlas","_updateTextTexCoord","_updateGeometryData","_check","w","h","addVertex","sprites","positionBufferData","opacityBufferData","addTextVertex","textSprites","textPositionData","maxPointCount","texCoordBufferData","textTexCoordData","_initBuffers","updateData","positions","texCoordIndex","bin","tl","br","_fillTexCoord","textTexCoordIndex","_fillTextTexCoord","_initTexture","config","mag","premultiplyAlpha","_clusterTexture","update","device","texture","_clusterMesh","setUniform","_initTextTexture","_textTexture","_textMesh","texWidth","texHeight","u1","v1","u2","v2","addVertexTexCoord","addTextTexCoord","IconAtlas","RGBAImage","getVectorPacker","icons","iconMap","url","icon","isWebGL1","gl","WebGLRenderingContext","nonPowerOfTwo","texts","textMap","textSprite","putImageData","ImageData","Uint8ClampedArray","buffer","u","v","initContext","_initClusterShader","_initClusterMeshes","dispose","destroy","extraCommandProps","viewport","depth","enable","blend","func","src","dst","reshader","MeshShader","name","vert","frag","wgslVert","wgslFrag","spriteCluster","aPosition","aTexCoord","aOpacity","positionSize","generateBuffers","Mesh","Scene","Renderer","Float32Array","isNil"],"mappings":"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"}